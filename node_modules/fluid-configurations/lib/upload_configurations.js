/**
 * Uploads configurations to S3.
 *
 * We will use the original configuration mtime in order
 * to know if a file should be uploaded or not to S3.
 *
 * Files will be uploaded to a location that matches the semver
 * of the fluid-configurations module. This will allow
 * us to evolve our configurations without the risk of breaking
 * implementations that might be using the configurations behind the scenes
 * to perform server side operations.
 *
 */

var async = require("async"),
  _ = require("lodash"),
  glob = require("glob"),
  path = require("path"),
  fs = require("fs"),

  // Internal modules
  getOptions = require("./options_parser"),
  buildIndex = require("./index_builder"),
  processConfigurations = require("./process_local_configurations"),
  s3 = require("./s3"),

  getProcessedPath = require("./processed_path"),
  getCatalogDir = getProcessedPath({
    type: "catalog",
    typeKey: "catalogId"
  }),
  getProductDir = getProcessedPath({
    type: "product",
    typeKey: "productId"
  }),
  getBaseDir = getProcessedPath({}),

  // Logger
  debug = require("debug")("fluid:configurations:uploader"),

  // Constants
  CONCURRENCY = parseInt(process.FLUID_S3_INDEXER_CONCURRENCY || 5, 10),

  // Private methods
  getLocalFilesOnIndex,
  memoizedGlob;

module.exports = function (options, callback) {
  options = _.defaults(getOptions(options), {
    s3: {
      bucket: "fluid-configurations",
      prefix: "/"
    }
  });

  async.auto({


    // Build the index if missing
    indexes: function (callback) {
      if (options.indexes) {
        debug("[info] Using explicit indexes");
        callback(null, options.indexes);
      } else {
        debug("[info] Building indexes");
        buildIndex(options, function (err, indexes) {
          if (err) { return callback(err); }
          debug("[info] %d entries added to the index", indexes.length);
          options.indexes = indexes;
          callback(null, indexes);
        });
      }
    },



    // Makes sure processes run before performing the upload
    process: ["indexes", function (callback, results) {
      if (options.skipProcessing) {
        debug("[info] Skipped processing");
        return callback();
      }
      debug("[info] Processing index");
      processConfigurations(_.defaults({
        indexes: results.indexes
      }, options), callback);
    }],



    // Builds a list of local json to upload based on the
    // elements on the index
    json_files: ["process", "indexes", function (callback, results) {
      debug("[info] Building list of local JSON files to upload");
      getLocalFilesOnIndex(
        results.indexes,
        function (s3Object) {
          return options.local_dir + "/json/" +
            (s3Object.environment || "*") + "/" +
            (s3Object.workflow || "*") + "/" +
            "customers/c" +
            (s3Object.customerId || "*") + "/**";
        },
        "admin-published json files",
        callback
      );
    }],



    // Scans the local file system for catalog optimized files to upload
    catalog_processed_files: ["indexes", "process", function (callback, results) {
      debug("[info] Building list of local catalog optimized files to upload");
      getLocalFilesOnIndex(
        results.indexes,
        function (s3Object) {
          return getCatalogDir(options.local_dir, _.defaults({}, s3Object, {
            environment: "*",
            workflow: "*",
            customerId: "*",
            catalogId: "*",
          })) + "/**";
        },
        "catalogs",
        callback
      );
    }],



    // Scans the local file system for product optimized files to upload
    product_processed_files: ["indexes", "process", function (callback, results) {
      debug("[info] Building list of local product optimized files to upload");
      getLocalFilesOnIndex(
        results.indexes,
        function (s3Object) {
          return getProductDir(options.local_dir, _.defaults({}, s3Object, {
            environment: "*",
            workflow: "*",
            customerId: "*",
            productId: "*"
          })) + "/**";
        },
        "products",
        callback
      );
    }],

    // Scans the local file system for product optimized files to upload
    relationship_files: ["indexes", "process", function (callback, results) {
      debug("[info] Building list of relationship files to upload");

      getLocalFilesOnIndex(
        results.indexes,
        function (s3Object) {
          return getBaseDir(options.local_dir, _.defaults({}, s3Object, {
            environment: "*",
            workflow: "*",
            customerId: "*",
          })) + "relations/*.json";
        },
        "relations",
        callback
      );
    }],



    // Scans the local file system for product optimized files to upload
    preferences_files: ["indexes", "process", function (callback, results) {
      debug("[info] Building list of preferences files to upload");

      getLocalFilesOnIndex(
        results.indexes,
        function (s3Object) {
          return getBaseDir(options.local_dir, _.defaults({}, s3Object, {
            environment: "*",
            workflow: "*",
            customerId: "*",
          })) + "preferences.json";
        },
        "preferences",
        callback
      );
    }],

    // Scans the local file system for customer settings optimized files to upload
    customer_processed_files: ["indexes", "process", function (callback, results) {
      debug("[info] Building list of local customer optimized files to upload");
      getLocalFilesOnIndex(
        results.indexes,
        function (s3Object) {
          return getBaseDir(options.local_dir, _.defaults({}, s3Object, {
            environment: "*",
            workflow: "*",
            customerId: "*",
          })) + "settings*.json";
        },
        "customers",
        callback
      );
    }],


    // Gets the list of base directories for the files that we are
    // about to upload, we use this information to scan for the
    // newest mtime on each environtment/workflow in order
    // to get the latest version to publish
    base_directories: ["indexes", "process", function (callback, results) {
      var dirs = [];
      _.each(results.indexes, function (s3Object) {
        dirs.push(getBaseDir(options.local_dir, s3Object));
      });
      callback(null, _.uniq(dirs));
    }],


    // Merges different processed files
    processed_files: [
      "catalog_processed_files",
      "product_processed_files",
      "customer_processed_files",
      "relationship_files",
      "preferences_files",
      function (callback, results) {
        debug("[info] Merging processed files.");

        callback(null,
          (results.catalog_processed_files || [])
            .concat(results.product_processed_files || [])
            .concat(results.customer_processed_files || [])
            .concat(results.relationship_files || [])
            .concat(results.preferences_files || [])
        );
      }
    ],


    // Combines json and processed files into a single array
    local_files: ["processed_files", "json_files", function (callback, results) {
      callback(null,
        _.uniq(
          _.flatten(
            (results.processed_files || []).concat((results.json_files || []))
          )
        )
      );
    }],


    // Gets a collection of [{remoteKey: localFiles}]
    remote_key_file_map: ["local_files", function (callback, results) {

      debug("[info] Building remote {Key: LocalFile} map.");

      var remote_key_file_map = _.map(results.local_files, function (file) {
          var entry = {},
            key = path.normalize(options.s3.prefix + file.replace(options.local_dir, "")).replace(/^\/*/, "");
          entry[key] = file;
          return entry;
        });

      callback(null, remote_key_file_map);
    }],



    // Gets a collection of [{localPath: mtime}]
    local_mtimes: ["local_files", function (callback, results) {
      var local_mtimes = {};

      debug("[info] Getting local file stats.");

      async.mapLimit(results.local_files, CONCURRENCY, function (file, callback) {
        fs.stat(file, function (err, stats) {
          local_mtimes[file] = (stats && stats.mtime && stats.mtime.getTime()) + "";
          callback();
        });
      }, function (err) {
        debug("[info] Got local file stats.");
        callback(err, local_mtimes);
      });
    }],



    // Performs a stat request on S3 to find out if the file
    // needs to be updated according to the last modification
    // time of the source configuration file that triggered
    // its creation
    s3_objects: ["remote_key_file_map", "local_mtimes", function (callback, results) {
      var entries = results.remote_key_file_map,
        objects_to_upload = [],
        up_to_date_objects = [];

      if (options.force) {
        debug("[info] Explicitly forcing re-uploading %d files.", entries.length);
      } else {
        debug("[info] Getting remote S3 Key stats.");
      }

      async.eachLimit(entries, CONCURRENCY, function (entry, callback) {
        var key = _.keys(entry)[0],
          local_file = entry[key];

        if (options.force) {
          entry[key] = local_file;
          objects_to_upload.push(entry);
          return callback();
        }

        s3.getPublishedFileInformation({}, {
          Key: key,
          Bucket: options.s3.bucket
        }, function (err, data) {
          var entry = {};

          if (err) {
            debug("[error] Failed getting S3 object info for %s on %s", key, options.s3.bucket);
            return callback(err);
          }

          if (
            // Could not find the file on S3
            data.notFound ||
            // The source configuration file has been updated
            results.local_mtimes[local_file] !== data.Metadata.sourcemtime
          ) {
            entry[key] = local_file;
            objects_to_upload.push(entry);
          } else {
            up_to_date_objects.push(data);
          }

          callback();
        });

      }, function (err) {
        debug("[info] %d files to upload, %d files up to date", objects_to_upload.length, up_to_date_objects.length);

        callback(err, {
          objects_to_upload: objects_to_upload,
          up_to_date_objects: up_to_date_objects
        });
      });
    }],



    // Uploads local files
    upload: ["s3_objects", "local_mtimes", function (callback, results) {
      var uploaded_objects = [],
        objects_to_upload = (results.s3_objects || {}).objects_to_upload || [];
      // params.Expires = distant future for processed
      // and near future for JSON files
      // Metadata: { sourceMtime: mtime}

      debug("[info] Uploading %d files to s3://%s.", results.s3_objects.objects_to_upload.length, options.s3.bucket);

      async.eachLimit(objects_to_upload, 2, function (entry, callback) {
        var key = _.keys(entry)[0],
          local_file = entry[key],
          s3_params = {
            Bucket: options.s3.bucket,
            Key: key,
            Metadata: {
              sourceMtime: results.local_mtimes[local_file]
            }
          };

        debug("[info] Uploading %s s3://%s/%s.", local_file, options.s3.bucket, s3_params.Key);

        setImmediate(function () {
          s3.uploadFile(local_file, s3_params, function (err, s3Object) {
            if (err) { return callback(err); }
            s3Object.local_file = local_file;
            uploaded_objects.push(s3Object);
            debug("[info] Uploaded file %s to s3://%s/%s.", local_file, options.s3.bucket, s3_params.Key);
            callback();
          });
        });

      }, function (err) {
        callback(err, uploaded_objects);
      });
    }]


  }, function (err, results) {
    results = results || {};
    var objects_to_upload = (results.s3_objects || {}).objects_to_upload || [];

    if (err) {
      console.log(err);
      debug("[error] Failed upload with error: %s. Stopped after uploading %d files to s3://%s.", err && err.message, objects_to_upload.length, options.s3.bucket);
    } else {
      debug("[info] Completed the upload of %d files to s3://%s.", objects_to_upload.length, options.s3.bucket);
    }

    callback(err,
      results.upload || [],
      results.s3_objects && results.s3_objects.up_to_date_objects || []
    );
  });

};


memoizedGlob = async.memoize(function (options, callback) {
  debug("[info] Searching for configurations on %s", options.glob_pattern);
  return glob(options.glob_pattern, options.glob_options, callback);
}, JSON.stringify);

/**
 * Scans the index for configuration files that match a pattern.
 */
getLocalFilesOnIndex = function (indexes, getGlobPattern, type, callback) {
  async.mapLimit(indexes, 1, function (s3Object, callback) {
    var glob_pattern = getGlobPattern(s3Object);
    if (!glob_pattern) {
      return callback(null, []);
    }

    setImmediate(function () {
      if (process.env.FLUID_CONFIGURATIONS_CLI_MODE) {
        memoizedGlob({
          glob_pattern: glob_pattern,
          glob_options: { mark: true }
        }, callback);
      } else {
        glob(glob_pattern, { mark: true }, callback);
      }
    });

  }, function (err, files) {
    files = _.filter(_.uniq(_.flatten(files)), function (file) {
      // Remove directories
      return !file.match(/\/$/);
    });
    debug("[info] Found %d configuration files for %s", files.length, type);

    callback(err, files);
  });
};
