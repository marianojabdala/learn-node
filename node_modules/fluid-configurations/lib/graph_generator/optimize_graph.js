/**
 * Generates an optimized version of the graph that uses
 * vertex array keys as indexes for linking edges.
 *
 * It also groups edges with the same edge types into edgeGroups
 */
var _ = require("lodash");

// Some vertices like views, might not have a canonical vertex
// and can be created from ags, cas...
// We will verify that we only include each vertex once and only once
function removeDuplicatedGraphEntries(type, options) {
  var includedChecksums = {},
    entries = [],
    getUniqueObjectId = options.utils.getUniqueObjectId;

  _.each(options.graph[type], function (item) {
    var checksum = getUniqueObjectId(item, 20);
    if (!includedChecksums[checksum]) {
      includedChecksums[checksum] = true;
      entries.push(item);
    }
  });
  options.graph[type] = entries;
}

function removeDuplicatedVertices(options) {
  removeDuplicatedGraphEntries("vertices", options);
}

function removeDuplicatedEdges(options) {
  removeDuplicatedGraphEntries("edges", options);
}


// Sorted vertices sort all but the product configuration
// which will remain the first element on the vertex
function sortVertices(graph) {
  var sortedVertex = [graph.vertices[0]];
  graph.vertices = sortedVertex.concat(
    _.sortBy(graph.vertices.slice(1), "ns")
  );

  return graph;
}

// Generates a graph.vertexIndex and graph.vertexOffset
function indexVertices(graph) {
  graph.vertexIndex = {};
  graph.vertexOffsets = {};
  _.each(graph.vertices, function (vertex, pos) {
    // Assuming vertices are sorted by ns (via sortVertices)
    // we can achieve faster lookups by on searching
    // on known ranges
    graph.vertexOffsets[vertex.ns] = graph.vertexOffsets[vertex.ns] || [pos, pos];
    graph.vertexOffsets[vertex.ns][1] = pos;
    graph.vertexIndex[vertex.ns + ":" + vertex.id] = pos;
  });

  return graph;
}

// Generates graph.edgeGroups and graph.issues
function createEdgeGroups(graph) {
  var edgeGroups = {},
    sortedByType = {},
    includedEdgesIndex = {};
  _.each(graph.edges, function (edge) {
    var type = edge.type || "undefined",
      properties = _.omit(edge, ["from", "to", "type"]),
      indexFrom = graph.vertexIndex[edge.from],
      indexTo = graph.vertexIndex[edge.to],
      edgeHash = edge.from + "|" + edge.to + "|" + type;

    if (includedEdgesIndex[edgeHash]) {
      // console.log("Duplicated edge " + edgeHash);
      return;
    }
    includedEdgesIndex[edgeHash] = true;

    if (type === "undefined") {
      console.log("undefined edge relationship for %j", edge);
    }

    if (_.isUndefined(indexFrom)) {
      graph.issues = graph.issues || [];
      graph.issues.push("Illegal edge " + edge.from + "(not found) > " + edge.to);
      return;
    } else if (_.isUndefined(indexTo)) {
      graph.issues = graph.issues || [];
      graph.issues.push("Illegal edge " + edge.from + " > " + edge.to + "(not found)");
      return;
    }

    edgeGroups[type] = edgeGroups[type] || [];

    if (_.size(properties) > 0) {
      edgeGroups[type].push([indexFrom, indexTo, properties]);
    } else {
      edgeGroups[type].push([indexFrom, indexTo]);
    }
  });

  // To make visually debugging edge groups simpler
  // and diffing more predictable we sort them by name
  _.each(_.keys(edgeGroups).sort(), function (type) {
    sortedByType[type] = _.uniq(edgeGroups[type]);
  });

  graph.edgeGroups = sortedByType;

  return graph;
}



module.exports = function (options) {
  if (!options.graph || options.graph.vertices.length === 0) {
    return options;
  }
  removeDuplicatedVertices(options);
  removeDuplicatedEdges(options);

  options.optimizedGraph = sortVertices(options.graph);
  options.optimizedGraph = indexVertices(options.optimizedGraph);
  options.optimizedGraph = createEdgeGroups(options.optimizedGraph);

  return options;
};
