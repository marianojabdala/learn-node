/**
 * Extracts facets from the product, cas and avs
 */
var _ = require("lodash");

function addFacetsForNs(ns, options, entry, entryId) {
  var getIdAsInt = options.utils.getIdAsInt,
    fromeEtryId = getIdAsInt(entryId);

  _.each(entry.facets, function (facet, facetId) {
    var id = getIdAsInt(facetId),
      edge = {
        from: ns + ":" + fromeEtryId,
        to: "f:" + id,
        type: facet.type === "hidden" ? "hasHiddenFacet" : "hasFacet"
      };
    options.graph.edges.push(edge);
  });
}

function addFacetsForCa(options, ca, caId) {
  addFacetsForNs("ca", options, ca, caId);
}

// We only need to know what facet values are included on a
// given attribute value. Therefore it looks like
// there is no need to get av > f > fv relationships
function linkAttributeValueFacetValues(options) {
  var getIdAsInt = options.utils.getIdAsInt;

  _.each(options.config.values, function (av, avId) {
    avId = getIdAsInt(avId);
    if (av.facets) {
      _.each(_.uniq(_.flatten(_.values(av.facets))), function (fvId) {
        fvId = getIdAsInt(fvId);
        options.graph.edges.push({
          from: "av:" + avId,
          to: "fv:" + fvId,
          type: "hasFacetValue"
        });
      });
    }
  });
}

/**
 * Products can contain facets defined at the top level.
 *
 * These facets are used mostly for providing categorization
 * and metadata for products and have no special meaning for
 * Fluid Configure. Implementors normally use these facets
 * to prepare the production orders.
 */
function addProductFacets(options) {
  var productVetexKey = "p:" + options.graph.vertices[0].id,
    productFacetCounter = 1;

  if (options.config.productFacets) {
    _.each(options.config.productFacets, function (pFacet) {
      options.graph.vertices.push({
        id: productFacetCounter,
        ns: "pf",
        name: pFacet.facetName,
        values: _.map(pFacet.facetValues || [], function (entry) {
          return entry.facetValueName;
        })
      });

      options.graph.edges.push({
        from: productVetexKey,
        to: "pf:" + productFacetCounter,
        type: "hasCustomFacets"
      });

      productFacetCounter += 1;

    });
  }
}


function linkCaFacets(options) {
  function extractFacetsFromCas(ca, id) {
    if (ca.facets) {
      addFacetsForCa(options, ca, id);
    }

    // Handle subAttributes
    if (ca.subAttributes) {
      _.each(ca.subAttributes, function (ca, caId) {
        extractFacetsFromCas(ca, caId);
      });
    }
  }
  _.each(options.config.attributes, function (ca, caId) {
    extractFacetsFromCas(ca, caId);
  });
}

function addFacetVerticesAndLinkToProduct(options) {

  var productVertexKey = "p:" + options.graph.vertices[0].id,
    getIdAsInt = options.utils.getIdAsInt;

  // Link root level facets to the product
  _.each(options.config.facets, function (facet, facetStringId) {
    var facetId = getIdAsInt(facetStringId),
      facetVertexKey = "f:" + facetId;

    options.graph.vertices.push(_.defaults({
      id: facetId,
      ns: "f"
    }, _.omit(facet, "facetValues")));

    options.graph.edges.push({
      from: productVertexKey,
      to: facetVertexKey,
      type: facet.type === "hidden" ? "hasHiddenFacet" : "hasFacet"
    });

    if (facet.facetValues) {
      _.each(facet.facetValues, function (fv, fvId) {
        fvId = getIdAsInt(fvId);
        options.graph.vertices.push(_.defaults({
          id: fvId,
          ns: "fv"
        }, fv));

        options.graph.edges.push({
          from: facetVertexKey,
          to: "fv:" + fvId,
          type: "hasFacetValue"
        });
      });
    }

  });

}


function addFacets(options) {

  if (!options.config.facets) {
    return options;
  }

  addFacetVerticesAndLinkToProduct(options);
  addProductFacets(options);
  linkCaFacets(options);
  linkAttributeValueFacetValues(options);
}

module.exports = function (options) {
  addFacets(options);
  return options;
};
