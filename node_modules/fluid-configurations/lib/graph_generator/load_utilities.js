/**
 * Includes utility functions under options.utils that are required
 * by graph generation steps
 */


var
  _ = require("lodash"),
  crypto = require("crypto"),
  autocast = require("../autocast");


// Generates a unique consistent id for a JS object
// We can use this to unify repeated data structures like prices
// into a single vertex.
function getUniqueObjectId(data, length) {
  var shasum = crypto.createHash("sha1");
  return shasum.update(JSON.stringify(data)).digest("hex").slice(0, length || 6) + "";
}

// Converts a fluid string id into a numeric id.
// for example p_ca_1234_av5677 > 5677
function getIdAsInt(id) {
  try {
    return parseInt((id + "").match(/([\d]+)$/)[0], 10);
  } catch (e) {
    return id;
  }
}

/**
 * Sometimes we don't have all the information we need
 * represented as vertices/edges, in those cases we will
 * append to the graph a list of future relationships to be solved
 *
 * @param {[type]} options
 *        options.configEntry       // Config entry that holds the relationships
 *        options.relationshipTypes // This a list relationship properties that are no longer
 *                                  // on the vertex.
 *        options.vertexKey         // Vertex that holds the relationship
 */
function addFutureRelationships(options) {
  var
    // Config entry that holds the relationships
    configEntry = options.configEntry,
    // This a list relationship properties that are no longer
    // on the vertex.
    relationshipTypes = options.relationshipTypes,

    // Vertex that holds the relationship
    vertexKey = options.vertexKey,

    futureRelationships = {};


  // Includes relationships that haven't been resolved yet into
  // options.graph.relationships[ns:123][type] = values;

  _.each(relationshipTypes, function (type) {
    if (configEntry[type]) {
      futureRelationships[type] = configEntry[type];
    }
  });
  options.graph.relationships[vertexKey] = futureRelationships;
}


// Helper utility to extract a list of relationships generated via addFutureRelationships
function getDelayedRelationships(options) {
  var delayedRelationships = {};
  _.each(options.graph.relationships, function (relationships, fromKey) {
    if (relationships[options.type]) {
      _.each(relationships[options.type], function (entry) {
        if (entry.indexOf(options.primaryKeyPrefix) === 0) {
          var id = getIdAsInt(entry);
          delayedRelationships[id] = delayedRelationships[id] || [];
          delayedRelationships[id].push(fromKey);
        }
      });
    }
  });

  return delayedRelationships;
}





module.exports = function (options) {
  options.utils = {
    // Converts stringified fields into JS native types
    autocast: autocast,
    // Converts a fluid string id into a numeric id.
    // for example p_ca_1234_av5677 > 5677
    getIdAsInt: getIdAsInt,
    // Generates a unique consistent id for a JS object
    getUniqueObjectId: getUniqueObjectId,

    // Allows defering the resolution of future relationships
    addFutureRelationships: addFutureRelationships,

    // Grab a list of delated relationships
    getDelayedRelationships: getDelayedRelationships
  };
  return options;
};
