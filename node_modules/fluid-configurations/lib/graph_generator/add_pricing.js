/**
 * Pricing can be defined in the following locations:
 *
 *   - base product price
 *   - value usage upcharge
 *   - attribute value upcharge
 *
 * When customers have only one currency pricing comes as a string,
 * whereas when using multiple currencies it comes as a hash such as
 * { CURRENCY: valueString }
 *
 * This module will also include available currencies at the product
 * level.
 */

var _ = require("lodash");

/**
 * To generate consistent hashing of prices we want to include
 * prices sorted by key (normally consistent on V8)
 */
function sortCollectionByKey(collection) {
  var sorted = {};
  _.each(_.keys(collection).sort(), function (key) {
    sorted[key] = collection[key];
  });
  return sorted;
}

/**
 * Given an upcharge string or object this method
 *
 * - normalizes string upcharges as a single currency
 * multicurrency object.
 * - Casts up-charges to numbers
 * - Remove 0 up-charges as they are meaningless.
 * - Sorts upcharges by currency
 * - Generates a unique id for the upcharge
 * - Adds the upcharge to the graph vertices
 * - Returns the price vertex
 *
 * @param  {string/object} upcharge String or multi-currency upcharge
 * @param  {String} Pricing description
 * @param  {Object} options
 * @return {priceVertex}
 */
function getPriceVertex(price, description, options) {
  var vertex,
    autocast = options.utils.autocast,
    getUniqueObjectId = options.utils.getUniqueObjectId;

  // Upcharge might just be a string, in such cases
  // we will default to USD and treat it as a multi currency entry
  // with just a default currency
  if (_.isString(price)) {
    price = { USD: price };
  }

  // We want to autocast prices at this point in order to be able
  // to merge them properly
  price = _.transform(_.mapValues(price, autocast), function (result, value, key) {
    if (value > 0) {
      result[key] = value;
    }
  });

  // Ignore empty upcharges
  if (_.size(price) > 0) {
    price = sortCollectionByKey(price);

    if (description !== "") {
      price.description = description;
    }

    vertex = _.defaults({
      id: getUniqueObjectId(price),
      ns: "uc"
    }, price);

    options.graph.vertices.push(vertex);
  }

  return vertex;
}


// Most av's include upcharges to 0. We will slim down
// the graph by grouping equal prices and only adding
// the edge whenever there is a real price or description
function addAttributeValueUpcharges(options, priceVertices) {
  var config = options.config,
    getIdAsInt = options.utils.getIdAsInt;

  _.each(config.values || {}, function (av, id) {
    id = getIdAsInt(id);
    var upchargeVertex;

    if (av.upcharge) {
      upchargeVertex = getPriceVertex(av.upcharge, av.pricingDescription || "", options);
      // If the up-charge only includes 0 values no vertex
      // will be included
      if (upchargeVertex) {

        priceVertices[upchargeVertex.id] = upchargeVertex;

        options.graph.edges.push({
          from: "av:" + id,
          to: "uc:" + upchargeVertex.id,
          type: "upcharges"
        });

      }
    }
  });
}


function addProductCurrencies(options, priceVertices) {
  var currencies = [],
    basePrice = options.config.priceConfiguration && options.config.priceConfiguration.basePrice;

  if (basePrice) {
    if (_.isString(basePrice)) {
      currencies = ["USD"];
    } else {
      currencies = _.keys(basePrice);
    }
  }

  _.each(priceVertices, function (prices) {
    currencies = currencies.concat(_.keys(_.omit(prices, ["id", "ns", "description"])));
  });
  currencies = (_.uniq(currencies) || ["USD"]);

  options.graph.vertices[0].currencies = currencies;
}


module.exports = function (options) {
  var priceVertices = {};

  addAttributeValueUpcharges(options, priceVertices);
  addProductCurrencies(options, priceVertices);

  return options;
};

// We want to get price vertices from link_value_usages as well
module.exports.getPriceVertex = getPriceVertex;

