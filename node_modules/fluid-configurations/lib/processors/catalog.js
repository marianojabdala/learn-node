/**
 * Creates a catalog optimized configuration file.
 *
 * The catalog configuration file includes the bare minimum information necessary
 * to render the catalog and it's refinements.
 *
 * The configuration file will be saved in a RESTful path such
 *
 *    /configuration/customer/:customerId/workflow/:workflow/:type/:id.json
 *
 * This will allow us to simplify parsing the arguments required to generate
 * the file dynamically.
 *
 * This task will inspect Cloud Search indexes to find out what refinements
 * the customer uses.
 */
var debug = require("debug")("fluid:configurations:processor:catalog"),
  fs = require("fs"),
  async = require("async"),
  cloudSearch = require("../cloud_search"),
  path = require("path"),
  _ = require("lodash"),
  glob = require("glob"),
  writeAndTouch = require("../write_and_touch"),
  getJson = require("../get_json"),
  doctor = require("../doctor"),
  format = require("util").format,
  ATTRIBUTE_VALUE_REGEXP = /(.+)_av\d+$/,
  validate = require("../validators/catalog"),
  getProcessedDir = require("../processed_path")({
    type: "catalog",
    typeKey: "catalogId"
  });



module.exports = function (options, processorCallback) {

  // We only want to intercept catalog configuration files
  if (options.s3Object.type !== "catalogConfig") {
    return setImmediate(function () {
      processorCallback();
    });
  }


  var
    getProductJsonPath,
    getCustomerBaseDir,
    getProductBaseDir,
    getCatalogBaseDir,
    getCatalogLocaleFiles,
    getCatalogTemplateFiles,
    getCustomerLocaleFiles,
    getLocalizedFiles,
    getTranslatedCollection,
    getReferencedDictionaryEntries,
    getProductLocaleFiles,

    getProcessingTime,
    startTime = (new Date()).getTime(),

    writeConfig,

    s3Object = options.s3Object,
    local_dir = options.local_dir,
    json_filename = options.json_file,
    dirname = getProcessedDir(local_dir, s3Object),
    filename = path.normalize(dirname + "/settings.json"),
    mtime = new Date(options.s3Object.LastModified),
    doctorIssues = [],
    // List of files required to build the combined catalog file
    filesInvolved = [];

  fs.stat(filename, function (err, stats) {
    if (!options.force && stats && stats.mtime && stats.mtime.toString() === mtime.toString()) {
      debug("[info] Up to date catalog processor %s", filename);
      return processorCallback(null, {files: [filename]});
    }

    debug("[info] Processing catalog: %j", _.pick(s3Object, ["workflow", "customerId", "catalogId"]));

    var auto_tasks = {


      // Retrieves the catalog configuration JSON
      catalogJson: ["customerConfig", function (callback, results) {
        if (!results.customerConfig) {
          return callback(null, false);
        }
        getJson(json_filename, function (err, json) {
          if (err) {
            debug("[error] Invalid Catalog JSON on %s got error %s", json_filename, err.message);
            return callback(err, false);
          }
          callback(null, json);
        });
      }],





      // Gets the list of product ids include on the catalog configuration
      catalogProducts: ["catalogJson", "customerConfig", function (callback, results) {
        if (!results.customerConfig) {
          return callback(null, false);
        }
        // Some legacy configurtions on staging don't include
        // results.catalogJson.products
        return callback(null, (results.catalogJson.products || []).map(function (id) {
            return parseInt(id.replace("p_", ""), 10);
          }));
      }],




      // Gets the list of locales the catalog or the customer uses.
      publishedLocales: ["catalogJson", "customerConfig", function (callback, results) {
        if (!results.customerConfig || !results.catalogJson) {
          return callback(null, false);
        }
        try {

          // The default locale is present regardless of the multilingual configuration
          var locales = _.pluck(results.catalogJson.searchSettings || [], "locale");

          if (results.catalogJson.localization && results.catalogJson.localization.locales) {
            locales = locales.concat(_.keys(results.catalogJson.localization.locales));
          }

          locales = _.compact(_.uniq(locales));

          if (!locales || locales.length === 0) {
            throw new Error("No locales for catalog");
          }
          callback(null, locales);
        } catch (e) {
          doctorIssues.push(["Missing localization details"]);
          callback(null, false);
        }
      }],




      // Loads the configuration for the products included on the catalog
      productConfigs: ["catalogProducts", "customerConfig", function (callback, results) {
        if (!results.customerConfig) {
          return callback(null, false);
        }
        async.mapLimit(results.catalogProducts || [], 5, function (productId, callback) {
          var options = _.defaults({productId: productId, local_dir: local_dir}, s3Object),
            product_path = getProductJsonPath(options),
            result = {};

          getJson(product_path, function (err, json) {
            if (err) {
              doctorIssues.push(["The product \"%s\" is referenced but has not been published yet", productId]);
              result[productId] = false;
            } else {
              result[productId] = json;
            }
            callback(null, result);
          });

        }, callback);
      }],




      // Loads the configuration for the products included on the catalog
      productLocalization: ["catalogProducts", "customerConfig", "publishedLocales", function (callback, results) {
        if (!results.customerConfig || !results.publishedLocales) {
          return callback(null, false);
        }

        var available_locales = results.publishedLocales;

        async.mapLimit(results.catalogProducts || [], 5, function (productId, callback) {
          var options = _.defaults({productId: productId, local_dir: local_dir, available_locales: available_locales}, s3Object);
          // TODO: Fi18n files are huge, we should stream the JSON and cherry pick
          // only what's needed
          getProductLocaleFiles(options, function (err, localeFiles) {
            var result = {};
            result[productId] = localeFiles;
            setImmediate(function () {
              callback(null, result);
            });
          });
        }, callback);
      }],




      // Loads the customer configuration JSON
      customerConfig: function (callback) {
        var configPath = getCustomerBaseDir(_.defaults({local_dir: local_dir}, s3Object)) + "/configureHtmlData.json";

        getJson(configPath, function (err, customerConfig) {
          if (err) {
            doctorIssues.push(["Missing customer \"%s\" configuration on \"%s/%s\".", s3Object.customerId, s3Object.environment, s3Object.workflow]);
            return callback(null, false);
          }
          if (!customerConfig.catalog || !customerConfig.catalog.catalogs || customerConfig.catalog.catalogs.indexOf("" + s3Object.catalogId) === -1) {
            doctorIssues.push(["Customer \"%s\" configuration on \"%s/%s\" doesn't know about the catalog \"%s\" search domain and API key", s3Object.customerId, s3Object.environment, s3Object.workflow, s3Object.catalogId]);
            // return callback(null, false);
            customerConfig.catalog = {};
          }
          callback(null, customerConfig);
        });
      },




      // Gets index fields (attribute aliases) for product attributes as included
      // on Cloud Search indexes
      indexedFields: ["customerConfig", function (callback, results) {
        if (!results.customerConfig) {
          return callback(null, false);
        }
        try {
          var searchDomain = results.customerConfig.catalog.searchDomain;
          cloudSearch.getCatalogFields({
            DomainName: searchDomain
          }, function (err, fields) {
            if (err || !fields || fields.length === 0) {
              doctorIssues.push(["Could not get index fields for the search domain \"%s\". Make sure the search domain has been created and is properly configured", searchDomain]);
              return callback(null, false);
            }
            callback(err, fields);
          });
        } catch (e) {
          doctorIssues.push(["Could not get searchDomain details"]);
          callback(null, false);
        }
      }],




      // Loads the configuration for the products included on the catalog
      customerLocalization: ["customerConfig", "publishedLocales", function (callback, results) {
        if (!results.customerConfig || !results.publishedLocales) {
          return callback(null, false);
        }
        var options = _.defaults({local_dir: local_dir, available_locales: results.publishedLocales}, s3Object);
        // TODO: Fi18n files are huge, we should stream the JSON and cherry pick
        // only what's needed
        getCustomerLocaleFiles(options, callback);
      }],




      // Loads the configuration for the products included on the catalog
      catalogLocalization: ["catalogJson", "publishedLocales", function (callback, results) {
        if (!results.catalogJson || !results.publishedLocales) {
          return callback(null, false);
        }
        var options = _.defaults({local_dir: local_dir, available_locales: results.publishedLocales}, s3Object);
        // TODO: Fi18n files are huge, we should stream the JSON and cherry pick
        // only what's needed
        getCatalogLocaleFiles(options, callback);
      }],




      // Loads the configuration for the products included on the catalog
      searchHitTemplates: ["catalogJson", "publishedLocales", function (callback, results) {
        if (!results.catalogJson || !results.publishedLocales) {
          return callback(null, false);
        }

        var options = _.defaults({local_dir: local_dir}, s3Object);
        // TODO: Fi18n files are huge, we should stream the JSON and cherry pick
        // only what's needed
        getCatalogTemplateFiles(options, function (err, result) {
          var messed_up_locales = {};

          _.each(result || {}, function (template, locale) {
            // Locale not declared on the catalog. Might have been removed.
            if (results.publishedLocales.indexOf(locale) === -1) {
              doctorIssues.push(["Template locale \"%s\" is not part of the catalog locales %j. Will try to change it to \"%s\" if no \"%s\" is found", locale, results.publishedLocales, results.publishedLocales[0]]);
              messed_up_locales[results.publishedLocales[0]] = template;
              delete result[locale];
            }

            template.engine = template.engine || "dust.js";

            if (template.engine !== "dust.js") {
              doctorIssues.push(["Template for the locale \"%s\" uses the incompatible template engine \"%s\"", locale, template.engine]);
              delete result[locale];
            } else if (template.html === "") {
              doctorIssues.push(["Template for the locale \"%s\" is empty", locale]);
              delete result[locale];
            } else if (template.html.indexOf("{{html") !== -1) {
              doctorIssues.push(["Template with \"%s\" locale syntax looks like jQuery tmpl. Only dust.js syntax is supported for catalog search hits.", locale]);
            }
          });

          // Try to fix messed up locales. This has been seen on monolingual catalogs
          _.each(messed_up_locales, function (template, locale) {
            if (!result[locale]) {
              result[locale] = template;
            }
          });

          callback(err, result);
        });
      }],




      // Gets a list of product aliases on the catalog configuration file for
      // each locale.
      // We will only include aliases that are referenced on the templates
      productAliases: ["publishedLocales", "catalogJson", function (callback, results) {
        if (!results.publishedLocales) {
          return callback(null, false);
        }
        var productAliases = {},
          products;

        try {
          if (results.catalogJson && results.catalogJson.searchSettings) {
            _.each(results.publishedLocales, function (locale) {
              productAliases[locale] = productAliases[locale] || {};
              products = _.where(results.catalogJson.searchSettings, {locale: locale}) || [];
              if (products[0] && products[0].products) {
                products = products[0].products;
                _.each(_.flatten(_.pluck(products, "attributes")), function (attribute) {
                  productAliases[locale][attribute.alias] = attribute.name;
                });
              }
            });
          }
        } catch (e) {
          debug("[error] Failed getting product aliases from %s searchSettings with error %s", s3Object.url, e.message);
          doctorIssues.push(["Failed getting product aliases from searchSettings"]);
        }
        callback(null, productAliases);
      }],





      // Gets a localized collection translated attribute value names
      translatedAttributeValueNames: ["catalogJson", "publishedLocales", "catalogLocalization", function (callback, results) {
        getTranslatedCollection({
          locales: results.publishedLocales,
          collection: results.catalogJson.attributeValueNames,
          dictionary: results.catalogLocalization
        }, callback);
      }],




      // Gets a localized collection translated product names
      translatedProductNames: ["catalogJson", "publishedLocales", "catalogLocalization", function (callback, results) {
        getTranslatedCollection({
          locales: results.publishedLocales,
          collection: results.catalogJson.productNames,
          dictionary: results.catalogLocalization
        }, callback);
      }],





      // Generates a unified localization for each catalog and product based on the
      // customer localization, the default locales, catalog localization and product
      // localization
      mergedLocalizations: ["publishedLocales", "productLocalization", "catalogLocalization", "customerLocalization", "productAliases", "translatedProductNames", "translatedAttributeValueNames", function (callback, results) {
        if (!results.publishedLocales) {
          return callback(null, false);
        }
        var mergedLocalizations = _.clone(results.productAliases || {}),
          locale_types = ["customerLocalization", "productLocalization", "catalogLocalization", "translatedProductNames", "translatedAttributeValueNames"];

        try {
          _.each(results.publishedLocales, function (locale) {
            _.each(locale_types, function (locale_type) {
              var merged = {};

              // Product localizations
              // include a collection of {product_id: {locale: {key: value}}}
              // entries
              if (results[locale_type]) {
                if (_.isArray(results[locale_type])) {
                  _.each(results[locale_type], function (entry) {
                    try {
                      entry = _.values(entry)[0];
                      if (entry[locale]) {
                        merged = _.defaults({}, merged, entry[locale]);
                      }
                    } catch (e) {}
                  });
                } else {
                  merged = results[locale_type][locale];
                }
                // console.log(locale_type, _.keys(merged));
                mergedLocalizations[locale] = mergedLocalizations[locale] || {};
                mergedLocalizations[locale] = _.defaults(mergedLocalizations[locale], merged);
              }
            });
          });
        } catch (e) {
          debug("[error] Failed merging localizations for %s with error %s", s3Object.url, e.message);
          doctorIssues.push(["Failed merging localizations"]);
        }

        // console.log("mergedLocalizations", mergedLocalizations);

        callback(null, mergedLocalizations);
      }],




      // Gets the list of attributes and localization variables used on a template
      //
      // We also perform partial searches by looking at the attribute values.
      //
      //  For example:
      //
      //    "size_av27945": "Size - XXS (5)",
      //    "size_av27946": "Size - XS (6)",
      //    "size_av27947": "Size - S (7-8)",
      //    "size_av27948": "Size - M (10-12)",
      //    "size_av27949": "Size - L (14-16)",
      //
      //
      // will all be included if the "size" string is found on the template.
      searchHitTemplateLocales: ["searchHitTemplates", "mergedLocalizations", function (callback, results) {
        if (!results.searchHitTemplates) {
          return callback(null, false);
        }

        getReferencedDictionaryEntries({
          // Search on all templates
          searchTarget: _.pluck(_.values(results.searchHitTemplates), "html").join(""),
          dictionary: results.mergedLocalizations
        }, callback);
      }],





      // Gets the localizations for search index fields.
      indexedFieldLocales: ["indexedFields", "mergedLocalizations", function (callback, results) {
        if (!results.indexedFields || !results.mergedLocalizations) {
          return callback(null, false);
        }
        getReferencedDictionaryEntries({
          searchTarget: results.indexedFields.join(" "),
          dictionary: results.mergedLocalizations
        }, callback);
      }],




      // Gets a unified key: value collection with all the localizable strings.
      dictionary: ["publishedLocales", "searchHitTemplateLocales", "indexedFieldLocales", function (callback, results) {
        if (!results.publishedLocales) {
          return callback(null, false);
        }
        var dictionary = {};
        _.each(results.publishedLocales, function (locale) {
          var translatedProductNames = (results.translatedProductNames && results.translatedProductNames[locale]) || {},
           indexedFieldLocales = (results.indexedFieldLocales && results.indexedFieldLocales[locale]) || {},
           searchHitLocales = (results.searchHitTemplateLocales && results.searchHitTemplateLocales[locale]) || {};

          dictionary[locale] = _.defaults({}, translatedProductNames, searchHitLocales, indexedFieldLocales);
        });

        callback(null, dictionary);
      }],


      // Aliases used on the template. We can use this
      // information to limit the data sent by the API
      // for each search hit.
      configurationAttributes: ["productAliases", "searchHitTemplates", function (callback, results) {
        if (!results.productAliases) {
          return callback(null, false);
        }
        getReferencedDictionaryEntries({
          // Search on all templates
          searchTarget: _.pluck(_.values(results.searchHitTemplates), "html").join(""),
          dictionary: results.productAliases
        }, function (err, results) {
          var combinedAliases = [];
          if (_.size(results) > 0) {
            combinedAliases = _.uniq(_.flatten(_.map(_.values(results), _.keys)));
          }
          callback(null, combinedAliases);
        });
      }]

    };



    // Collects catalog issues found on previous tasks and reports the
    // issues to the doctor
    auto_tasks.catalogIssues = _.keys(auto_tasks).concat(function (callback) {
      var issues = [];
      _.each(doctorIssues, function (issue) {
        issues.push(format.apply(null, issue));
        issue[0] += " on catalog %s";
        issue.push(s3Object.Key);
        doctor.addIssue.apply(null, issue);

      });
      callback(null, issues);
    });





    // The unifiedCatalogConfig task makes use of all previously designed
    // auto tasks and generates a multi-lingual catalog configuration file
    // that can be used as a fallback if no explicit locale is defined
    // by the implementor
    auto_tasks.unifiedCatalogConfig = _.keys(auto_tasks).concat(function (callback, results) {
      if (!results.customerConfig) {
        return callback(null, false);
      }

      var locales = results.publishedLocales || "en_us",
        globalCatalogConfig = {
          // customer: results.customerConfig,
          apiKey: results.customerConfig.catalog.apiKey,
          searchDomain: results.customerConfig.catalog.searchDomain,
          environment: s3Object.environment,
          workflow: s3Object.workflow,
          catalogId: s3Object.catalogId,
          products: results.catalogProducts,
          locales: locales
        };


      if (results.catalogJson.localization) {
        globalCatalogConfig.defaultLocale = results.catalogJson.localization.defaultLocale;
      } else {
        globalCatalogConfig.defaultLocale = locales[0];
      }

      globalCatalogConfig.gridSettings = _.omit(results.catalogJson.componentsConfiguration.recipesGrid, ["item", "showItemButtonsByDefault", "header", "pagination"]);
      globalCatalogConfig.dictionary = results.dictionary;
      globalCatalogConfig.templates = {
        search_hit: results.searchHitTemplates
      };

      globalCatalogConfig.configurationAttributes = results.configurationAttributes || [];

      globalCatalogConfig.sourceConfigurations = _.map(filesInvolved, function (path) {
        return path.replace(local_dir, "");
      });

      callback(null, globalCatalogConfig);
    });



    // Using lib/validators/catalog.js and the schema on schemas/fluidSocialCatalog.json
    // validates the global configuration and adds issues to the configuration if they
    // have been previously reported.
    auto_tasks.validatedGlobalConfig = ["unifiedCatalogConfig", function (callback, results) {
      if (!results.unifiedCatalogConfig) {
        return callback(null, false);
      }
      var validatedGlobalConfig = results.unifiedCatalogConfig;
      validate(validatedGlobalConfig, function (err, errors) {
        if (err) {
          results.catalogIssues = results.catalogIssues || [];
          results.catalogIssues = results.catalogIssues.concat(errors);
        }
        if (results.catalogIssues && results.catalogIssues.length > 0) {
          validatedGlobalConfig.issues = results.catalogIssues;
        }
        callback(null, validatedGlobalConfig);
      });
    }];



    // Splits the unified and validated configuration into locale specific
    // configurations.
    auto_tasks.singleLocaleCatalogConfigs = ["validatedGlobalConfig", "publishedLocales", function (callback, results) {
      if (!results.publishedLocales) {
        return callback(null, false);
      }
      var localizedConfigs = {},
        validatedGlobalConfig = results.validatedGlobalConfig;
      _.each(results.publishedLocales, function (locale) {
        localizedConfigs[locale] = _.omit(validatedGlobalConfig, ["defaultLocale", "templates", "dictionary", "sourceConfigurations"]);
        localizedConfigs[locale].defaultLocale = locale;
        localizedConfigs[locale].templates = {
          search_hit: {}
        };
        localizedConfigs[locale].templates.search_hit[locale] = validatedGlobalConfig.templates.search_hit[locale];
        localizedConfigs[locale].dictionary = {};
        localizedConfigs[locale].dictionary[locale] = validatedGlobalConfig.dictionary[locale];
      });
      callback(null, localizedConfigs);
    }];


    // Save one configuration file per locale and set their mtime to
    // match the main configuration file
    auto_tasks.saveValidatedGlobalCatalogConfig = ["validatedGlobalConfig", function (callback, results) {
      if (!results.validatedGlobalConfig) {
        return callback(null, false);
      }
      writeConfig({
        filename: filename,
        mtime: mtime,
        json: results.validatedGlobalConfig
      }, callback);
    }];

    // Save one configuration file per locale and set their mtime to
    // match the main configuration file
    auto_tasks.saveLocalizedConfigurations = ["singleLocaleCatalogConfigs", function (callback, results) {
      if (!results.singleLocaleCatalogConfigs) {
        return callback(null, false);
      }

      async.each(_.values(results.singleLocaleCatalogConfigs), function (configuration, callback) {
        var locale = configuration.defaultLocale,
          filename = dirname + "/settings-" + locale + ".json";

        writeConfig({
          filename: filename,
          mtime: mtime,
          json: configuration
        }, callback);

      }, callback);

    }];


    // console.log(catalogJson);

    async.auto(auto_tasks, function (err, results) {
      var files = _.compact(_.flatten(_.values(_.pick(results, "saveLocalizedConfigurations", "saveValidatedGlobalCatalogConfig"))));
      // console.log(err, "translatedProductNames", results && results.translatedProductNames); // results.productConfigs
      // console.log(JSON.stringify(results.singleLocaleCatalogConfigs, null, 2)); // results.productConfigs

      debug("[info] Completed processing catalog: %j in %s", _.pick(s3Object, ["workflow", "customerId", "catalogId"]), getProcessingTime());

      processorCallback(err, {files: files});
    });
  });





  writeConfig = function (options, callback) {
    writeAndTouch(options.filename, JSON.stringify(options.json), options.mtime, function (err) {
      callback(err, options.filename);
    });
  };


  getCustomerBaseDir = function (options) {
    return path.normalize(options.local_dir + "/json/" + options.environment + "/" + options.workflow + "/customers/c" + options.customerId + "/configureHtml");
  };

  getCatalogBaseDir = function (options) {
    return path.normalize(getCustomerBaseDir(options) + "/galleries/g_" + options.catalogId);
  };

  getProductBaseDir = function (options) {
    return path.normalize(getCustomerBaseDir(options) + "/products/p_" + options.productId);
  };

  getProductJsonPath = function (options) {
    var file_path = path.normalize(getProductBaseDir(options) + "/configureHtmlProductData.json");
    filesInvolved.push(file_path);
    return file_path;
  };

  getProductLocaleFiles = function (options, callback) {
    getLocalizedFiles(
      getProductBaseDir(options) + "/Fi18n*.json",
      /.*Fi18n_configure_product_(.+)\.json$/,
      options.available_locales,
      callback);
  };

  getCatalogLocaleFiles = function (options, callback) {
    getLocalizedFiles(
      getCatalogBaseDir(options) + "/Fi18n*.json",
      /.*Fi18n_gallery_(.+)\.json$/,
      options.available_locales,
      callback);
  };

  getCustomerLocaleFiles = function (options, callback) {
    getLocalizedFiles(
      getCustomerBaseDir(options) + "/localization/Fi18n*.json",
      /.*Fi18n_configure_(.+)\.json$/,
      options.available_locales,
      callback);
  };


  getCatalogTemplateFiles = function (options, callback) {
    getLocalizedFiles(
      path.normalize(getCatalogBaseDir(options) + "/../templates/") + "gallery_" + options.catalogId + "*.json",
      /.*gallery_\d+_(.+)\.json$/,
      options.available_locales,
      callback);
  };

  getLocalizedFiles = function (glob_pattern, locale_match, available_locales, callback) {
    glob(glob_pattern, function (err, files) {
      var result = {};
      async.eachLimit(files, 5, function (file, callback) {
        var locale = file.replace(locale_match, "$1");
        if (!available_locales || (available_locales && available_locales.indexOf(locale) !== -1)) {
          getJson(file, function (err, json) {
            result[locale] = json;
            filesInvolved.push(file);
            callback(err);
          });
        } else {
          callback();
        }
      }, function (err) {
        callback(err, result);
      });
    });
  };


  getTranslatedCollection = function (options, callback) {
    if (!options.locales || !options.dictionary) {
      return callback(null, false);
    }
    var translated = {};

    _.each(options.locales, function (locale) {
      var localization = options.dictionary[locale];
      translated[locale] = {};
      _.each(options.collection, function (value, key) {
        if (localization) {
          var localeKey = (value || "").replace("{", "").replace("}", "");
          translated[locale][key] = localization[localeKey] || value;
        } else {
          translated[locale][key] = value;
        }
      });
    });

    callback(null, translated);
  };


  getReferencedDictionaryEntries = function (options, callback) {
    var result = {};

    _.each(options.dictionary, function (values, locale) {
      _.each(values, function (value, key) {
        var search_string = key.replace(ATTRIBUTE_VALUE_REGEXP, "$1");
        if (options.searchTarget.indexOf(search_string) !== -1) {
          result[locale] = result[locale] || {};
          result[locale][key] = value;
        }
      });
    });

    callback(null, result);
  };


  getProcessingTime = function () {
    return (new Date()).getTime() - startTime;
  };


};


