/**
 * The relationships processor generates an index of published
 * customer, products and catalog relationships.
 *
 * Generated files include:
 *
 *  - customer/:id/relations/product_catalogs.json
 */
var processedPath = require("../processed_path"),
  getBaseProcessedDir = processedPath({}),
  getCatalogProcessedDir = processedPath({
    type: "catalog",
    typeKey: "catalogId"
  }),
  mkdirp = require("mkdirp"),
  getJson = require("../get_json"),
  path = require("path"),
  _ = require("lodash"),
  async = require("async"),
  fs = require("fs"),
  queues = {};


// We don't want to write multiple times to the same file
// so we need to make sure calls follow an order
// At the same time we don't want to use blocking IO fs calls
// As that would slow things down for other customer configurations
function getQueueForRelationsJson(options) {
  var relations_path = options.product_catalogs_path;

  if (queues[relations_path]) {
    return queues[relations_path];
  }

  queues[relations_path] = async.queue(function (task, callback) {

    async.waterfall([

      function catalogSettings(callback) {
        getJson(task.catalog_path, function (err, catalogSettings) {
          callback(null, catalogSettings || {
            error: err.message
          });
        });
      },

      function extendRelations(catalogSettings, callback) {
        if (catalogSettings.error) {
          return callback(null, catalogSettings);
        }
        getJson(relations_path, function (ignorableErr, data) {
          data = data || {};
          _.each(catalogSettings.products || [], function (productId) {
            data[productId] = data[productId] || [];
            data[productId].push(catalogSettings.catalogId);
            data[productId] = _.uniq(data[productId]);
          });

          callback(null, data);
        });
      },

      function writeRelationsFile(data, callback) {

        mkdirp(path.dirname(relations_path), function () {
          setImmediate(function () {
            fs.writeFile(relations_path, JSON.stringify(data), callback);
          });
        });
      }

    ], function (err) {
      if (err) {
        return callback(new Error("Can't generate relations/product_catalogs.json. " +
          "With error: " + err.message));
      }
      callback();
    });

  }, 1);

  return queues[relations_path];
}


// Include catalogId into customer/:id/catalogs.json
// and add catalog references for the products
// on customer/:id/products.json
function addCatalogToReports(options, callback) {
  var
    s3Object = options.s3Object,
    base_dir = getBaseProcessedDir(options.local_dir, s3Object),
    catalog_dir = getCatalogProcessedDir(options.local_dir, s3Object),
    catalog_path = path.normalize(catalog_dir + "/settings.json"),
    product_catalogs_path = path.normalize(base_dir + "/relations/product_catalogs.json"),
    queue;

  queue = getQueueForRelationsJson({
    product_catalogs_path: product_catalogs_path,
    s3Object: s3Object
  });

  queue.push({
    catalog_path: catalog_path
  }, function (err) {
    callback(err, {files: [product_catalogs_path]});
  });

}


module.exports = function (options, callback) {
  if (options.s3Object.type === "catalogConfig") {
    addCatalogToReports(options, callback);
  } else {
    return setImmediate(function () {
      callback();
    });
  }
};
