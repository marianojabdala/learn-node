/**
 * Creates a product optimized configuration file.
 *
 * The product configuration file includes the bare minimum information necessary
 * to render the product.
 *
 * TODO:
 *
 *  - Translate localized configurations in order to avoid localization
 *    logic on the consumers of the configuration
 *  - Cast invalid booleans and integers and date to avoid extra computation
 *    on clients.
 *  - Create report for products with useful debug and inspector information.
 *    This report should include issues and file sizes.
 *  - Build optimized data structures for efficient runtime usage.
 */
var fs = require("fs"),
  async = require("async"),
  path = require("path"),
  _ = require("lodash"),
  glob = require("glob"),
  writeAndTouch = require("../write_and_touch"),
  doctor = require("../doctor"),
  format = require("util").format,
  s3 = require("../s3"),
  getJson = require("../get_json"),
  getProcessedDir = require("../processed_path")({
    type: "product",
    typeKey: "productId"
  }),
  autocast = require("../autocast"),
  generateGraph = require("../graph_generator/"),
  generateD3Graph = require("../graph_generator/generate_d3_insight_graph"),
  validate = require("../validators/product");


module.exports = function (options, callback) {

  // We only want to intercept product configuration files
  if (options.s3Object.type !== "productConfig") {
    return setImmediate(function () {
      callback();
    });
  }


  var
    getProductJsonPath,
    getCustomerBaseDir,
    getProductBaseDir,
    getProductLocaleFiles,
    getCustomerLocaleFiles,
    getLocalizedFiles,
    translateAndCastConfiguration,

    writeConfig,

    debug = require("debug")("fluid:configurations:processor:product"),

    s3Object = options.s3Object,
    local_dir = options.local_dir,
    json_filename = options.json_file,
    dirname = getProcessedDir(local_dir, s3Object),
    filename = path.normalize(dirname + "/settings.json"),
    mtime = new Date(options.s3Object.LastModified),
    doctorIssues = [],
    // List of files required to build the combined product file
    filesInvolved = [];

  fs.stat(filename, function (err, stats) {

    if (!options.force && stats && stats.mtime && stats.mtime.toString() === mtime.toString()) {
      return callback(null, {files: [filename]});
    }

    debug("[info] Processing product: %j", _.pick(s3Object, ["workflow", "customerId", "productId"]));

    var auto_tasks = {

      // Loads the customer configuration JSON
      customerConfig: function (callback) {
        var configPath = getCustomerBaseDir(_.defaults({local_dir: local_dir}, s3Object)) + "/configureHtmlData.json";
        getJson(configPath, function (err, customerConfig) {
          if (err) {
            doctorIssues.push(["Missing customer \"%s\" configuration on \"%s/%s\".", s3Object.customerId, s3Object.environment, s3Object.workflow]);
            return callback(null, false);
          }
          callback(null, customerConfig);
        });
      },



      // Loads the product configuration
      productConfig: function (callback) {
        getJson(json_filename, function (err, json) {
          if (err) { return callback(err); }
          var productConfig = _.defaults({
              id: s3Object.productId,
              type: s3Object.type,
              environment: s3Object.environment,
              workflow: s3Object.workflow,
              productId: s3Object.productId,
              customerId: s3Object.customerId
            }, json);
          callback(null, productConfig);
        });
      },



      // Gets the list of locales the product or the customer uses.
      publishedLocales: ["customerConfig", "productConfig", function (callback, results) {
        if (!results.customerConfig || !results.productConfig) {
          return callback(null, false);
        }
        try {

          var locales = [];

          if (results.customerConfig.localization && results.customerConfig.localization.locales) {
            locales = locales.concat(_.keys(results.customerConfig.localization.locales));
          }

          locales = _.compact(_.uniq(locales));

          if (locales.length === 0) {
            locales = ["en_us"];
          }

          callback(null, locales);
        } catch (e) {
          doctorIssues.push(["Missing localization details"]);
          callback(null, false);
        }
      }],


      validateImagesExist: ["productConfig", function (callback, results) {
        if (!options.validateProductImagesOnS3) {
          return callback(null, true);
        }

        var folder = "images/";
        try {
          if (results.productConfig.utils.imageGeneration.strategy === "scene7") {
            folder = "thumbs/";
          }
        } catch (e) {
        }

        s3.getPublishedImages({
          max: 1,
          folder: folder,
          product: results.productConfig
        }, function (err, images) {
          var sucess = false;
          if (err) {
            doctorIssues.push(["Failed listing images with error: " + err.message]);
          } else if (images.length < 1) {
            doctorIssues.push(["No images where found"]);
          } else {
            sucess = true;
          }
          callback(null, sucess);
        });
      }]

    };




    // Collects product issues found on previous tasks and reports the
    // issues to the doctor
    auto_tasks.productIssues = _.keys(auto_tasks).concat(function (callback) {
      var issues = [];
      _.each(doctorIssues, function (issue) {
        issues.push(format.apply(null, issue));
        issue[0] += " for product %s";
        issue.push(s3Object.Key);
        doctor.addIssue.apply(null, issue);

      });
      callback(null, issues);
    });





    // The unifiedProductConfig task makes use of all previously designed
    // auto tasks and generates a multi-lingual product configuration file
    // that can be used as a fallback if no explicit locale is defined
    // by the implementor
    auto_tasks.unifiedProductConfig = _.keys(auto_tasks).concat(function (callback, results) {
      if (!results.customerConfig) {
        return callback(null, false);
      }

      var locales = results.publishedLocales || "en_us",
        globalProductConfig = results.productConfig;

      globalProductConfig.locales = locales;

      if (results.customerConfig.localization) {
        globalProductConfig.defaultLocale = results.customerConfig.localization.defaultLocale;
      } else {
        globalProductConfig.defaultLocale = locales[0];
      }

      globalProductConfig.dictionary = results.dictionary || {};

      callback(null, globalProductConfig);
    });


    auto_tasks.unifiedProductConfigWithGraphs = ["unifiedProductConfig", function (callback, results) {
      if (!results.unifiedProductConfig) {
        return callback(null, false);
      }
      var configWithGraphs = results.unifiedProductConfig;

      configWithGraphs.generatedGraph = generateGraph(results.unifiedProductConfig);

      return callback(null, configWithGraphs);
    }];

    // Using lib/validators/product.js and the schema on schemas/fluidSocialProduct.json
    // validates the global configuration and adds issues to the configuration if they
    // have been previously reported.
    auto_tasks.validatedGlobalConfig = ["unifiedProductConfigWithGraphs", function (callback, results) {
      if (!results.unifiedProductConfigWithGraphs) {
        return callback(null, false);
      }
      var validatedGlobalConfig = results.unifiedProductConfigWithGraphs;
      validate(validatedGlobalConfig, function (err, errors) {
        if (err) {
          results.productIssues = results.productIssues || [];
          results.productIssues = results.productIssues.concat(errors);
        }
        if (results.productIssues && results.productIssues.length > 0) {
          validatedGlobalConfig.issues = results.productIssues;
        }
        callback(null, validatedGlobalConfig);
      });
    }];




    auto_tasks.productDictionaries = ["publishedLocales", function (callback, results) {
      getProductLocaleFiles(_.defaults(
        {
          available_locales: results.publishedLocales
        }, options, options.s3Object), callback);
    }];


    // Splits the unified and validated configuration into locale specific
    // configurations.
    auto_tasks.localizedConfigs = ["validatedGlobalConfig", "publishedLocales", "productDictionaries", function (callback, results) {
      if (!results.publishedLocales) {
        return callback(null, false);
      }

      var localizedConfigs = {},
        validatedGlobalConfig = results.validatedGlobalConfig;

      // translateAndCastConfiguration
      _.each(results.publishedLocales, function (locale) {
        var dictionary;

        localizedConfigs[locale] = _.omit(validatedGlobalConfig, [
          "areasConfiguration", "dictionary"
        ]);
        localizedConfigs[locale].locale = locale;
        if (validatedGlobalConfig.areasConfiguration) {
          localizedConfigs[locale].areas = true;
        }

        dictionary = results.productDictionaries[locale] ||
          results.productDictionaries[validatedGlobalConfig.defaultLocale] || {};

        delete localizedConfigs[locale].localization;

        // We need to be able to skip translations for generating test fixtures
        // that should not include translated or autocasted fields.
        if (process.env.SKIP_TRANSLATION) {
          localizedConfigs[locale] = _.omit(localizedConfigs[locale], "areasConfiguration");
        } else {
          localizedConfigs[locale] = translateAndCastConfiguration(localizedConfigs[locale], dictionary);
        }
      });

      callback(null, localizedConfigs);
    }];


    // Save one configuration file per locale and set their mtime to
    // match the main configuration file
    auto_tasks.saveValidatedGlobalProductConfig = ["validatedGlobalConfig", function (callback, results) {
      if (!results.validatedGlobalConfig) {
        return callback(null, false);
      }

      writeConfig({
        filename: filename,
        mtime: mtime,
        json: _.omit(results.validatedGlobalConfig, [
          "areasConfiguration", "localization", "generatedGraph"
        ])
      }, callback);
    }];


    // Save the areasConfiguration as areas.json
    auto_tasks.saveAreasConfiguration = ["validatedGlobalConfig", function (callback, results) {
      if (!results.validatedGlobalConfig || !results.validatedGlobalConfig.areasConfiguration) {
        return callback(null, false);
      }
      writeConfig({
        filename: dirname + "/areas.json",
        mtime: mtime,
        json: results.validatedGlobalConfig.areasConfiguration
      }, callback);
    }];


    // Save one configuration file per locale and set their mtime to
    // match the main configuration file
    auto_tasks.saveLocalizedConfigurations = ["localizedConfigs", function (callback, results) {
      if (!results.localizedConfigs) {
        return callback(null, false);
      }

      async.mapLimit(_.values(results.localizedConfigs), 1, function (configuration, callback) {
        var locale = configuration.locale,
          filename = dirname + "/settings-" + locale + ".json";

        writeConfig({
          filename: filename,
          mtime: mtime,
          json: _.omit(configuration, "generatedGraph")
        }, callback);

      }, callback);

    }];



    // Save one configuration file per locale and set their mtime to
    // match the main configuration file
    auto_tasks.saveLocalizedGraphs = ["localizedConfigs", function (callback, results) {
      if (!results.localizedConfigs) {
        return callback(null, false);
      }

      async.mapLimit(_.values(results.localizedConfigs), 1, function (configuration, callback) {
        var locale = configuration.locale,
          filename = dirname + "/graph-settings-" + locale + ".json",
          productVertex = configuration.generatedGraph.optimizedGraph.vertices[0];

        // Add extra info to the product
        productVertex.locale = locale;
        productVertex.areas = configuration.areas;

        configuration.generatedGraph.optimizedGraph.vertices[0] = productVertex;

        writeConfig({
          filename: filename,
          mtime: mtime,
          json: _.pick(configuration.generatedGraph.optimizedGraph, "vertices", "edgeGroups")
        }, callback);

      }, callback);

    }];



    // Save one configuration file per locale and set their mtime to
    // match the main configuration file
    auto_tasks.saveRenderizableGraphs = ["localizedConfigs", function (callback, results) {
      if (!results.localizedConfigs) {
        return callback(null, false);
      }

      async.mapLimit(_.values(results.localizedConfigs), 1, function (configuration, callback) {
        var locale = configuration.locale,
          filename = dirname + "/graph-" + locale + ".json";

        writeConfig({
          filename: filename,
          mtime: mtime,
          json: generateD3Graph(configuration.generatedGraph.graph)

        }, callback);

      }, callback);

    }];


    async.auto(auto_tasks, function (err, results) {
      var files = _.compact(_.flatten(_.values(_.pick(results,
        "saveLocalizedConfigurations",
        "saveLocalizedGraphs",
        "saveRenderizableGraphs",
        "saveAreasConfiguration",
        "saveValidatedGlobalProductConfig"))));
      callback(err, {files: files});
    });
  });





  writeConfig = function (options, callback) {
    writeAndTouch(options.filename, options.data || JSON.stringify(options.json), options.mtime, function (err) {
      callback(err, options.filename);
    });
  };


  getCustomerBaseDir = function (options) {
    return path.normalize(options.local_dir + "/json/" + options.environment + "/" + options.workflow + "/customers/c" + options.customerId + "/configureHtml");
  };

  getProductBaseDir = function (options) {
    return path.normalize(getCustomerBaseDir(options) + "/products/p_" + options.productId);
  };

  getProductJsonPath = function (options) {
    var file_path = path.normalize(getProductBaseDir(options) + "/configureHtmlProductData.json");
    filesInvolved.push(file_path);
    return file_path;
  };

  getProductLocaleFiles = function (options, callback) {
    getLocalizedFiles(
      getProductBaseDir(options) + "/Fi18n*.json",
      /.*Fi18n_configure_product_(.+)\.json$/,
      options.available_locales,
      callback);
  };

  getCustomerLocaleFiles = function (options, callback) {
    getLocalizedFiles(
      getCustomerBaseDir(options) + "/localization/Fi18n*.json",
      /.*Fi18n_configure_(.+)\.json$/,
      options.available_locales,
      callback);
  };


  getLocalizedFiles = function (glob_pattern, locale_match, available_locales, callback) {
    glob(glob_pattern, function (err, files) {
      var result = {};
      async.eachLimit(files, 5, function (file, callback) {
        var locale = file.replace(locale_match, "$1");
        if (!available_locales || (available_locales && available_locales.indexOf(locale) !== -1)) {
          return getJson(file, function (err, json) {
            result[locale] = json;
            filesInvolved.push(file);
            callback();
          });
        }
        callback();
      }, function () {
        callback(null, result);
      });
    });
  };


  translateAndCastConfiguration = function (configuration, dictionary) {
    dictionary = dictionary || {};
    var
      mapMethod = _.isArray(configuration) ? _.map : _.mapValues,
      translatedConfiguration = mapMethod(_.omit(configuration, "areasConfiguration"), function (value) {
      var translationId = (value + "").replace(/^\{(.+)\}$/, "$1");

      if (_.isString(dictionary[translationId])) {
        return dictionary[translationId];
      } else if (_.size(value) > 0 && (_.isObject(value) || _.isArray(value))) {
        return translateAndCastConfiguration(value, dictionary);
      } else {
        return autocast(value);
      }
    });
    return translatedConfiguration;
  };


};
