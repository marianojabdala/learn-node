/**
 * The customer processor generates an optimized version of the customer
 * configuration file.
 *
 * The customer configuration file has a TTL of just 5 minutes
 * on the CDN. It is mostly used to instruct customers
 * where to fetch the product, or catalog configurations from.
 *
 * The processedVersion field defines what version of the processed
 * configurations should be loaded.
 *
 * Generated files:
 *
 *  - customer/:id/settings-:locale.json
 *  - customer/:id/settings.json  // for the default locale
 */

var writeAndTouch = require("../write_and_touch"),
  getProcessedDir = require("../processed_path")({}),
  path = require("path"),
  _ = require("lodash"),
  async = require("async"),
  validate = require("../validators/customer"),
  fs = require("fs");

module.exports = function (options, callback) {

  // We only want to intercept customer configuration files
  if (options.s3Object.type !== "customerConfig") {
    return setImmediate(function () {
      callback();
    });
  }

  var mtime = new Date(options.s3Object.LastModified),
    s3Object = options.s3Object,
    local_dir = options.local_dir,
    json_filename = options.json_file,
    dirname = getProcessedDir(local_dir, s3Object),
    settings_filename = path.normalize(dirname + "/settings-en_us.json");

  fs.stat(settings_filename, function (err, stats) {
    if (stats && stats.mtime && stats.mtime.toString() === mtime.toString()) {
      return callback(null, {files: [settings_filename]});
    }

    async.auto({

      // Loads the customer configuration as json
      jsonBuffer: function (callback) {
        fs.readFile(json_filename, callback);
      },

      baseConfig: ["jsonBuffer", function (callback, results) {
        var config = JSON.parse(results.jsonBuffer);

        // Sets defaults
        config.id = s3Object.customerId;
        config.type = s3Object.type;
        config.customerId = s3Object.customerId;
        config.workflow = s3Object.workflow;
        config.environment = s3Object.environment;

        callback(null, config);
      }],

      // gets the locales defined on the config or defaults to ["en_us"]
      locales: ["baseConfig", function (callback, results) {
        var config = results.baseConfig,
          locales;
        try {
          locales = {
            available: _.keys(config.localization.locales),
            "default": config.localization.defaultLocale
          };
        } catch (e) {
          locales = {
            available: ["en_us"],
            "default": "en_us"
          };
        }
        callback(null, locales);
      }],


      // Gets the configuration files to be saved
      localizedConfigurations: ["locales", "baseConfig", function (callback, results) {
        var getLocaleFile = function (locale, isDefault) {
            // We need a copy of the config before modifying it
            var config = JSON.parse(JSON.stringify(results.baseConfig)),
              filename = isDefault === true ? "settings.json" : "settings-" + locale + ".json";

            // TODO flatten locales, include translated settings
            // pull localization/Fi18n_configure_{code}.js info into
            // each individual localized file
            config.locale = config.locale || {};
            config.locale.code = locale;
            config.locale.availableLocales = results.locales;

            return {
              path: path.normalize(dirname + "/" + filename),
              locale: locale,
              config: config
            };
          },

          files;

        setImmediate(function () {
          files = _.map(results.locales.available, getLocaleFile);
          files.push(getLocaleFile(results.locales.default, true));
          callback(null, files);
        });
      }],


      // Validates configurations and includes the issues on the configuration
      // files as well as under results.customerIssues
      validatesConfigurations: ["localizedConfigurations", function (callback, results) {
        async.map(results.localizedConfigurations, function (details, callback) {
          validate(details.config, function (err, errors) {
            if (err) {
              results.customerIssues = results.customerIssues || [];
              results.customerIssues = results.customerIssues.concat(errors);
            }
            if (results.customerIssues && results.customerIssues.length > 0) {
              details.config.issues = results.customerIssues;
            }
            callback(null, details);
          });
        }, callback);
      }],

      savedPreferences: ["validatesConfigurations", function (callback, results) {
        async.map(results.validatesConfigurations, function (details, callback) {
          writeAndTouch(details.path, JSON.stringify(details.config), mtime, function (err) {
            callback(err, details.path);
          });
        }, callback);
      }]

    }, function (err, results) {
      callback(err, {files: results.savedPreferences});
    });

  });
};
