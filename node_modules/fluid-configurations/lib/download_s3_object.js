var path = require("path"),
  fs = require("fs"),
  os = require("os"),
  httpClient = require("http-get"),
  async = require("async"),
  debug = require("debug")("fluid:configurations:download"),
  writeAndTouch = require("./write_and_touch");

module.exports = function (s3Object, options, callback) {
  options = options || {};
  s3Object = s3Object || {};

  if (!options.local_dir) {
    options.local_dir = path.normalize(os.tmpdir() + "/fluid-configurations/");
  }

  async.auto({

    // Resolve the local file path
    file_path: function (callback) {
      var err = s3Object.Key ? null : new Error("Missing s3Object.Key"),
        file_path = path.normalize(options.local_dir + "/admin-published/" + s3Object.Key);
      callback(err, file_path);
    },

    // Checks whether the local file is older than the remote one
    // if mdate is false the file will not be re-downloaded.
    // When the reDownload option is passed the mtime will be set
    // to 1 in order to force a download
    mtime: ["file_path",
      function (callback, results) {
        var mdate = new Date(s3Object.LastModified);
        fs.stat(results.file_path, function (err, stats) {
          if (stats && stats.mtime && stats.mtime.toString() === mdate.toString()) {
            mdate = false;
          }
          if (options.reDownload) {
            mdate = 1;
          }
          callback(null, mdate);
        });
      }
    ],


    // Downloads the file from S3
    download: ["mtime",
      function (callback, results) {
        if (!results.mtime) { return callback(null, false); }

        debug("[info] Downloading %s", s3Object.url);

        httpClient.get({
          url: s3Object.url,
          bufferType: "buffer"
        }, function (err, res) {
          if (err) {
            debug("[error] Failed downloading %s with error %s", s3Object.url, err.message);
            return callback(null, false);
          }
          callback(err, res.buffer);
        });
      }
    ],

    // Saves the file locally and touches the file with the
    // remote modification time
    save: ["download", "file_path", "mtime",
      function (callback, results) {

        if (!results.mtime || !results.download) { return callback(null, false); }

        writeAndTouch(
          results.file_path,
          results.download,
          new Date(s3Object.LastModified),
          callback);
      }
    ]

  }, function (err, results) {
    if (!results.mtime) { return callback(err); }
    callback(err, results.file_path);
  });

};
