/**
 * ## Index builder.
 *
 * The index builder scans S3 for published configurations
 * and collects basic information based on the rules on
 * lib/published_information/ and lib/configure/indices
 *
 * At glance the following tasks are performed in order to
 * build an index.
 *
 * - Get all customer ids and workflows for an environment
 * - For each customer get all the
 *   - Catalogs ID's and the workflows where they are included
 *   - Product ID's and the workflows where they are included
 * - Get all customer configuration indexes
 * - Get all catalog configuration indexes
 * - Get all catalog template indexes
 * - Get all catalog localization file indexes
 * - Get all product configuration indexes
 * - Get all product localization file indexes
 *
 * Example:
 *
 *    fluidConfigurations.getPublishedIndexes({
 *      customer: 1443,
 *      workflow: "prod",
 *      environment: "prod"
 *    }, function (err, indexes) {
 *      console.log(indexes);
 *    });
 *
*/

var async = require("async"),
  _ = require("lodash"),
  fs = require("fs"),
  dateJs = require("date.js"),
  debug = require("debug")("fluid:configurations:index-builder"),

  memoize = require("./memoizer"),

  writeAndTouch = require("./write_and_touch"),
  getOptions = require("./options_parser"),
  concurrency = parseInt(process.FLUID_S3_INDEXER_CONCURRENCY || 5, 10),

  flattenIndices,
  getCatalogOrProductIdsAndWorkflows,
  getScopedIndexGrabber,
  getPublishedIndexes,
  getCachedIndices,
  getIndices;


getPublishedIndexes = function getPublishedIndexes(options, callback) {
  options = getOptions(options || {});
  options.environment = options.environment || "prod";


  debug("[info] Building index for %j", options);

  var autoTasks = {

    // Get all customer ids and workflows for an environment
    customer_ids_and_workflows: function (callback) {
      debug("[info] Scanning customer ids and workflows");
      require("./published_information/customer_ids_and_workflows")(options, callback);
    },

    // For each customer and get all the Catalogs ID's and the workflows where
    // they are included
    customer_catalogs: ["customer_ids_and_workflows",
      function (callback, results) {
        debug("[info] Scanning customer catalogs and their workflows");
        getCatalogOrProductIdsAndWorkflows("customer_catalogs", results, callback);
      }
    ],

    // Product ID's and the workflows where they are included
    customer_products: ["customer_ids_and_workflows",
      function (callback, results) {
        debug("[info] Scanning customer products and their workflows");
        getCatalogOrProductIdsAndWorkflows("customer_products", results, callback);
      }
    ],

    // Customer configuration file indices
    customer_configurations: ["customer_ids_and_workflows",
      function (callback, results) {
        debug("[info] Building customer configuration indexes");
        getIndices("customer_config", results.customer_ids_and_workflows, callback);
      }
    ],

    // Product configuration file indices
    product_configurations: [
      "customer_products",
      getScopedIndexGrabber("customer_products", "product_config")
    ],

    // Catalog configuration file indices
    catalog_configurations: [
      "customer_catalogs",
      getScopedIndexGrabber("customer_catalogs", "catalog_config")
    ],

    // Catalog template indices
    catalog_templates: [
      "customer_catalogs",
      getScopedIndexGrabber("customer_catalogs", "catalog_template")
    ],

    // Product localization file indices
    product_localizations: [
      "customer_products",
      getScopedIndexGrabber("customer_products", "product_localization")
    ],

    // Catalog localization file indices
    catalog_localizations: [
      "customer_catalogs",
      getScopedIndexGrabber("customer_catalogs", "catalog_localization")
    ],

    // Catalog localization file indices
    customer_localizations: [
      "customer_ids_and_workflows",
      function (callback, results) {
        getIndices("customer_localization", results.customer_ids_and_workflows, callback);
      }
    ],

    // Merge indices
    merge_indices: [
      "customer_configurations",
      "customer_localizations",
      "product_configurations",
      "catalog_configurations",
      "catalog_templates",
      "product_localizations",
      "catalog_localizations",
      function (callback, results) {
        // console.log(results);
        callback(null, _.flatten(_.map(_.values(_.pick(results, [
          "customer_configurations",
          "customer_localizations",
          "product_configurations",
          "catalog_configurations",
          "catalog_templates",
          "product_localizations",
          "catalog_localizations"
        ])), _.values)));
      }
    ],


    // Adds the latest versions/mtime for each
    // environment + workflow + customerID
    // This will allow us to prefix the path where
    // processed configurations will be saved
    timestamped_indexes: ["merge_indices", function (callback, results) {
      var timestampedIndexes = [],
        latest_mtime_map = {},
        processedGroup, i;

      _.each(results.merge_indices, function (s3Object) {
        var processedGroup = [s3Object.environment, s3Object.workflow, s3Object.customerId].join("/"),
          mtime = new Date(s3Object.LastModified);
        if (!latest_mtime_map[processedGroup] || mtime > latest_mtime_map[processedGroup]) {
          latest_mtime_map[processedGroup] = mtime;
        }
        s3Object.processedGroup = processedGroup;
        timestampedIndexes.push(s3Object);
      });

      for (i = 0; timestampedIndexes.length > i; i += 1) {
        processedGroup = timestampedIndexes[i].processedGroup;
        timestampedIndexes[i].processedVersion = latest_mtime_map[processedGroup].getTime();
      }

      callback(null, timestampedIndexes);
    }],



    // Reduces the index size based on the user parameters
    filtered_indices: ["timestamped_indexes", function (callback, results) {
      var indices = results.timestamped_indexes,
        filteredIndices = [];

      _.each(options.customers, function (customerId) {
        filteredIndices.push(_.where(indices, {customerId: parseInt(customerId, 10)}));
      });

      if (filteredIndices.length > 0) {
        indices = _.compact(_.flatten(filteredIndices));
        filteredIndices = [];
      }

      // Removes products not included on the product list,
      // this is useful for testing, generating fixtures
      // and troubleshooting single product configurations
      if (options.products) {
        indices = _.filter(indices, function (idx) {
          var include = true;
          _.each(options.products, function (id) {
            if (idx.productId && idx.productId !== parseInt(id, 10)) {
              include = false;
            }
          });
          return include;
        });
      }

      if (options.where) {
        filteredIndices.push(_.where(indices, options.where));
      }

      if (filteredIndices.length > 0) {
        indices = _.compact(_.flatten(filteredIndices));
      }


      // Explicitly removes indexes that contain the type
      // catalog, product, customer....
      if (options.exclude) {
        indices = _.filter(indices, function (idx) {
          var include = true;
          _.each(options.exclude, function (type) {
            if (idx.type.indexOf(type) !== -1) {
              include = false;
            }
          });
          return include;
        });
      }

      callback(null, indices);
    }],

    persist_index: ["filtered_indices", function (callback, results) {
      if (options.index_file && results && results.filtered_indices) {
        debug("[info] Caching indexes on %s", options.index_file);

        writeAndTouch(
          options.index_file,
          JSON.stringify(results.filtered_indices),
          new Date(),
          callback);
      } else {
        callback();
      }
    }]

  };


  // If the index has been cached, return it right away
  getCachedIndices(options, function (err, cached_indices) {
    if (!err) {
      debug("[info] Using cached indexes from %s", options.index_file);
      return callback(null, cached_indices);
    }

    // otherwise run the list of auto tasks
    async.auto(autoTasks, function (err, results) {
      callback(err, results && results.filtered_indices);
    });
  });

};



getCachedIndices = function (options, callback) {

  if (!options.index_file) {
    return callback(new Error("No options.index_file was provided, not using cache"));
  }

  if (options.cache && options.cache === 0) {
    return callback(new Error("0 minute cache"));
  }

  if (options.cache && _.isNumber(options.cache)) {
    options.cache = options.cache + " seconds";
  }

  var mtime = dateJs((options.cache || "5m") + " ago");

  fs.stat(options.index_file, function (err, stats) {
    if (!err && stats && stats.mtime && stats.mtime.getTime() > mtime.getTime()) {
      fs.readFile(options.index_file, function (err, data) {
        if (err) { return callback(err); }
        callback(null, JSON.parse(data));
      });
    } else {
      callback(new Error("Not used local index"));
    }
  });
};




getIndices = function (index_type, results, callback) {
  var getIndex = require("./configure_indices/" + index_type);

  debug("[info] Downloading %s indices", index_type);

  async.mapLimit(_.values(results), concurrency * 2, function (entry, callback) {
    // console.log(entry);
    async.mapLimit(_.values(entry.workflows), Math.floor(concurrency / 2), function (workflow, callback) {
      debug("Downloading %s index for customer %d on the workflow %s", index_type, entry.customerId, workflow);
      // console.log(workflow);
      getIndex(_.defaults({
        workflow: workflow
      }, _.pick(entry, ["environment", "catalogId", "customerId", "productId"])), callback);
    }, callback);
  }, function (err, results) {
    results = _.compact(_.flatten(results || []));
    results = _.reject(results, function (entry) {
      return entry.notFound;
    });
    callback(err, results);
  });

};



getCatalogOrProductIdsAndWorkflows = function (resource_type, results, callback) {
  var getResourceAndWorkflows = require("./published_information/" + resource_type);

  debug("[info] Downloading " + resource_type + " ID's");

  async.mapLimit(_.values(results.customer_ids_and_workflows), concurrency, function (entry, callback) {

    debug("[info] Downloading %s ID's for customer %d", resource_type, entry.customerId);

    getResourceAndWorkflows(entry, function (err, resourceEntries) {
      var result = {};
      if (_.size(resourceEntries) > 0) {
        result[entry.customerId] = resourceEntries;
        callback(err, result);
      } else {
        callback(err);
      }
    });

  }, function (err, results) {
    results = _.compact(results || []);
    callback(err, results);
  });
};



flattenIndices = function (indices) {
  return _.flatten(_.map(_.flatten(_.map(_.values(indices), _.values)), _.values));
};


getScopedIndexGrabber = function (source_name, scope_name) {
  debug("[info] Building %s index", source_name);

  return function (callback, results) {
    var collection = flattenIndices(results[source_name]);
    getIndices(scope_name, collection, callback);
  };
};

module.exports = memoize(getPublishedIndexes, [
  "workflow", "workflows", "customers", "customer",
  "customerId", "local_dir", "environment",
  "processors", "where"
]);
