/**
 * The following module processes local configurations
 * by:
 *
 * - Generating or using an indexes array
 * - Downloading the files from S3 into {local_dir}/admin-published/
 * - Generating a json version of the files under {local_dir}/json/
 * - Running in parallel the processors described as the
 *   options.processors array. This processors might point to
 *   the bundled processors included under lib/processors or they
 *   might be referenced by a npm module name.
 *
 */

var
  // External modules
  glob = require("glob"),
  _ = require("lodash"),
  async = require("async"),
  path = require("path"),

  // Internal modules
  getOptions = require("./options_parser"),
  buildIndexes = require("./index_builder"),
  downloadConfigurations = require("./download_configurations"),

  // Logger
  debug = require("debug")("fluid:configurations:processor"),

  // Constants
  CONCURRENCY = parseInt(process.FLUID_S3_INDEXER_CONCURRENCY || 5, 10),
  PROCESSORS_BASE_DIR = process.env.FLUID_CONFIGURATION_PROCESSORS_BASE_DIR ||
    path.normalize(__dirname + "/processors/"),

  // Private functions
  loadLocalProcessors,
  getProcessor,
  runProcessor,
  processConfigurations,

  processorSettings = require("../config/processors.json"),
  availableProcessors = processorSettings.default
    .concat(processorSettings.post_processors),

  // Static cache. Once a processor is defined under
  // a name it will remain in memory for future usage.
  _processorsStaticCache;


processConfigurations = function (options, callback) {

  options = getOptions(options);
  options.processors = options.processors || availableProcessors;
  options.processors = _.isString(options.processors) ? options.processors.split(",") : options.processors;

  // The json processor will always run before running any other processor
  // so we can remove it from the list of processors
  options.processors = _.compact(
        _.uniq(
          _.without(options.processors || [], "json")
        )
      );


  if (options.processors.length > 0) {
    // The customer processor will always be the first on the list
    options.processors.unshift("customer");
    // The preferences processor will always go last
    options.processors.push("preferences");
    options.processors = _.uniq(options.processors);
  }

  async.auto({

    // Generates the indexes if no indexes are provided
    indexes: function (callback) {
      if (options.indexes) {
        return callback(null, options.indexes);
      }
      buildIndexes(options, callback);
    },

    // Downloads index entries that are newer on S3
    download: ["indexes", function (callback) {
      downloadConfigurations(options, callback);
    }],


    // Runs the default json processor
    process_json: ["download", function (callback, results) {
      runProcessor("json", options, results, callback);
    }],

    // Runs the explicit list of processing steps in parallel
    process: ["process_json", function (callback, results) {
      async.mapSeries(options.processors, function (name, callback) {
        runProcessor(name, options, results, function (err, result) {
          var nameSpacedResult = {};
          nameSpacedResult[name] = result;
          callback(err, nameSpacedResult);
        });
      }, function (err, results) {
        var processResults = {};
        _.each(results || [], function (value) {
          var key = _.keys(value)[0];
          processResults[key] = value[key];
        });
        callback(err, processResults);
      });
    }]

  }, function (err, results) {
    if (err) { return callback(err); }

    var processResults = _.defaults({
      json: results.process_json
    }, results.process);

    callback(null, processResults);
  });

};



// Private methods


loadLocalProcessors = function (callback) {
  if (_processorsStaticCache) {
    return callback(null, _processorsStaticCache);
  }

  glob(PROCESSORS_BASE_DIR + "*.js", function (err, files) {
    if (err) { return callback(err); }

    var localProcessors = {};

    try {
      files.forEach(function (file) {
        var processor_name = path.basename(file, ".js");
        debug("[info] Loading processor %s", processor_name);
        localProcessors[processor_name] = require(file);
      });
    } catch (e) {
      debug("[error] Failed loading local processors with error %s", e.message);
      return callback(e);
    }

    _processorsStaticCache = localProcessors;

    debug("[info] Loaded local processors %j", _.keys(localProcessors));

    callback(null, localProcessors);
  });
};



getProcessor = function (name, callback) {
  loadLocalProcessors(function (err, localProcessors) {
    callback(err, (localProcessors && localProcessors[name]) || require(name));
  });
};



runProcessor = function (name, options, results, callback) {

  getProcessor(name, function (err, processor) {
    if (err) {
      return callback(new Error("Failed loading processor " + name + " with error " + err.message));
    }

    debug("[info] Running %d %s processors in parallel", CONCURRENCY * 5, name);

    async.mapLimit(
      results.indexes,
      options.concurrency || CONCURRENCY * 5,
      function processS3Index(s3Object, callback) {
        var processor_options = _.defaults({
          s3Object: s3Object,
          admin_published_file: path.resolve(options.local_dir + "/admin-published/" + s3Object.Key)
        }, options),

        jsonDirname = path.normalize(processor_options.local_dir + "/json/" + path.dirname(processor_options.s3Object.Key));

        // We can easily run into
        // Maximum call stack size exceeded issues
        // unless we run this on the next tick
        setImmediate(function () {
          try {
            processor_options.json_file = path.normalize(jsonDirname + "/" + path.basename(processor_options.admin_published_file, ".js").replace(/_jsonp/, "") + ".json");
            processor(processor_options, callback);
          } catch (e) {
            debug("[error] Uncaught exception %s on processor %s, with options %j. " +
              "Full stack %s", e.message, name, processor_options, e.stack);
            callback(e);
          }
        });


      }, function (err, result) {
        var combinedResults = {},
          nameSpacedResult = {};

        if (err) {
          debug("[error] Failed running processor %s with error: %s", name, err.message);
        } else {
          debug("[info] Done running processor %s", name);
          _.each(result || [], function (entry) {
            _.each(entry, function (value, key) {
              if (_.isArray(value)) {
                combinedResults[key] = combinedResults[key] || [];
                combinedResults[key] = combinedResults[key].concat(value);
              } else if (_.isObject(value)) {
                combinedResults[key] = combinedResults[key] || {};
                combinedResults[key] = _.defaults({}, value, combinedResults[key]);
              } else {
                combinedResults[key] = combinedResults[key] || value;
              }
            });
          });
        }

        nameSpacedResult[name] = combinedResults;

        setImmediate(function () {
          callback(err, combinedResults);
        });
      });
  });
};




module.exports = processConfigurations;


