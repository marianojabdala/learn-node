var
  listLocalizedObjects,
  getPublishedEntities,
  getPublishedFileInformation,
  getPublishedImages,
  uploadFile,

  default_s3_params = {
    Bucket: process.env.AWS_S3_BUCKET || "fluid-configure-published"
  },

  // Cache control max age. 1 week by default.
  maxAge = parseInt(process.env.AWS_S3_OBJECT_MAX_AGE || (3600 * 24 * 7), 10),

  _ = require("lodash"),
  async = require("async"),
  fs = require("fs"),
  zlib = require("zlib"),
  mime = require("mime"),
  tmp = require("tmp"),
  crypto = require("crypto"),

  config = {
    s3: default_s3_params
  },
  debug = require("debug")("fluid:configurations:s3"),
  AWS = require("aws-sdk"),
  s3 = new AWS.S3(config.s3);

s3._params = default_s3_params;


/**
 * Gets a list of S3 localized files for a given customer environment workflow and catalog
 * or product
 */
listLocalizedObjects = function (options, params, callback) {
  var
    results = [],
    default_params = {
      Delimiter: "/",
      EncodingType: "url"
    },
    replaceRegExp;

  params = _.defaults({}, params, default_params, default_s3_params);

  replaceRegExp = new RegExp(
      "^" +
      params.Prefix.replace(/[\/]+/g, "\\/") +
      (options.replaceSuffix || "(.+)_jsonp") +
      "\\.js"
    );

  options = _.omit(options, "replaceSuffix");

  s3.listObjects(params, function (err, s3ObjectList) {
    if (err) {
      return callback(err);
    }

    _.map(s3ObjectList.Contents, function (s3Entry) {
      if (!s3Entry.Key.match(replaceRegExp)) {
        return;
      }
      var entry = _.omit(s3Entry, ["Owner", "StorageClass"]);
      entry.locale = s3Entry.Key.replace(replaceRegExp, "$1");
      entry.ETag = entry.ETag.replace(/["\\]+/g, "");
      entry.url = "http://" + params.Bucket + ".s3.amazonaws.com/" + s3Entry.Key;

      _.merge(entry, options);
      results.push(entry);
    });
    callback(null, results);
  });

};


/**
 * Gets a list of published entry types like catalogs
 * for a configure customer, published products
 */
getPublishedEntities = function (options, s3_params, callback) {
  var
    results = {},

    getCustomerWorkflows = require("./published_information/customer_workflows"),
    _getPublishedEntities,
    workflows = options.workflow ? [options.workflow] : options.workflows;

  if (!options.entryPrimaryKey) {
    return callback(new Error("Missing options.entryPrimaryKey"));
  }

  _getPublishedEntities = function (workflow, callback) {
    var params = {
        Delimiter: "/",
        EncodingType: "url"
      },
      prefixRegexp;

    params = _.defaults({}, s3_params, params, default_s3_params);
    params.Prefix = (params.Prefix || "").replace("{WORKFLOW}", workflow);
    prefixRegexp = new RegExp("^" + params.Prefix.replace(/[\/]+/g, "\\/"));

    s3.listObjects(params, function (err, data) {
      if (err) {
        return callback(err);
      }
      _.map(data.CommonPrefixes, function (entry) {
        var entryId = parseInt(entry.Prefix.replace(prefixRegexp, "").replace("/", "").replace(/[^\d]+/g, ""), 10);
        if (_.isNumber(entryId)) {
          results[entryId] = results[entryId] || _.defaults({
            workflows: []
          }, _.omit(options, "entryPrimaryKey", "workflows", "workflow"));

          results[entryId][options.entryPrimaryKey] = entryId;

          results[entryId].workflows.push(workflow);
          results[entryId].workflows = _.uniq(results[entryId].workflows);
        }
      });
      callback(null, results);
    });
  };

  if (workflows) {
    async.map(workflows, _getPublishedEntities, function (err) {
      if (err) {
        return callback(err);
      }
      callback(null, results);
    });
  } else {
    getCustomerWorkflows(options, function (err, workflows) {
      if (err) {
        return callback(err);
      }
      async.map(workflows, _getPublishedEntities, function (err) {
        if (err) {
          return callback(err);
        }
        callback(null, results);
      });
    });
  }
};


/**
 * Gets index information about a published file without having
 * to download the file.
 */
getPublishedFileInformation = function (options, s3_options, callback) {
  var params = _.defaults({}, s3_options, {
    Bucket: default_s3_params.Bucket
  });

  debug("s3.headObject with params: %j", params);

  s3.headObject(params, function (err, data) {
    data = _.defaults({}, data || {}, options);
    data.url = "http://" + params.Bucket + ".s3.amazonaws.com/" + params.Key;

    if (err) {
      if (err.statusCode === 404) {
        err = null;
        data.notFound = true;
      } else {
        debug("[error] s3.headObject with params: %j and error: %s", params, err.message || err);
      }
      return callback(err, data);
    }

    data.Key = params.Key;
    // @TODO:  Why are some ETags for configuration files double quoted?
    data.ETag = (data.ETag || "").replace(/\"/g, "");
    data.Size = parseInt(data.ContentLength, 10);
    callback(err, data);
  });
};


uploadFile = function (local_file, s3_options, callback) {
  var
    contentType = mime.lookup(local_file),
    shouldGzip = contentType.match(/text|javascript|json/),
    params = _.defaults({}, s3_options, {
      Bucket: default_s3_params.Bucket
    });

  async.auto({

    // Returns a local file path to upload
    // this might be a gzipped file
    file_path: function (callback) {
      if (!shouldGzip || params.Body) {
        return callback(null, local_file);
      }

      tmp.file(function (err, path) {
        var
          input = fs.createReadStream(local_file),
          output = fs.createWriteStream(path);

        // Gzip the file and upload when done.
        input
          .pipe(zlib.createGzip())
          .pipe(output)
          .on("error", callback)
          .on("close", function () {
            output.end();
            callback(null, path);
          });
      });
    },

    // Returns the compressed or uncompressed buffer
    buffer: ["file_path", function (callback, results) {
      if (params.Body) {
        return callback(null, params.Body);
      }

      fs.readFile(results.file_path, callback);
    }],

    // Ensure file integrity upon upload
    md5: ["file_path", function (callback, results) {
      if (params.ContentMD5) {
        return callback(null, params.ContentMD5);
      }
      callback(null, crypto
          .createHash("md5")
          .update(fs.readFileSync(results.file_path))
          .digest("base64"));
    }],

    // Sets the s3 params
    params: ["buffer", "md5", function (callback, results) {

      if (shouldGzip) {
        params.ContentEncoding = params.ContentEncoding || "gzip";
        params.ContentType = params.ContentType || (contentType + "; charset=utf-8");
      }

      params.ContentMD5 = params.ContentMD5 || results.md5;
      params.ContentType = params.ContentType || contentType;
      params.Body = params.Body || results.buffer;
      params.ContentLength = params.ContentLength || params.Body.length;
      params.CacheControl = params.CacheControl || ("max-age=" + maxAge);
      callback(null, params);
    }],


    upload: ["params", function (callback, results) {
      debug("s3.putObject with params: %j", _.omit(results.params, "Body"));
      s3.putObject(params, callback);
    }],

    response: ["upload", function (callback, results) {
      callback(null, _.defaults({}, results.upload, _.omit(params, "Body")));
    }]

  }, function (err, results) {
    callback(err, results.response);
  });
};

/**
 * Validates if the folder containing versioned assets
 * still exists on S3
 */
getPublishedImages = function (options, callback) {

  if (!options || !options.product) {
    return callback(new Error("Missing options.product"));
  }

  // prefix = "https://s3.amazonaws.com/fluid-configure-published/prod/dev-impl/customers/c1475/configureHtml/products/p_20361/configureHtmlProductData.js 1386873520334";
  var
    entryInfo = _.pick(options.product, ["environment", "workflow", "customerId", "configVersion", "productId"]),
    params = _.defaults({
      Delimiter: "/",
      EncodingType: "url",
      Prefix: entryInfo.environment + "/" + entryInfo.workflow + "/customers/c" + entryInfo.customerId + "/configureHtml/products/p_" + entryInfo.productId + "/" + entryInfo.configVersion + "/" + (options.folder || "images/"),
    }, default_s3_params);

  // debug("[info] Checking for images on %s", params.Prefix);

  entryInfo.type = "attributeImage";

  if (options.max) {
    params.MaxKeys = options.max;
  }

  s3.listObjects(params, function (err, data) {
    if (err) { return callback(err); }
    var results = [],
      contents = data.Contents || [];

    /*
    if (contents.length === 0) {
      debug("[error] Failed getting images on %s with data %j and error %s", params.Prefix, data, err && err.message);
    }
    */

    _.each(contents, function (s3Entry) {
      var entry = _.omit(s3Entry, ["Owner", "StorageClass"]);
      entry.url = "http://" + params.Bucket + ".s3.amazonaws.com/" + s3Entry.Key;
      _.merge(entry, entryInfo);
      results.push(entry);
    });
    callback(null, results);
  });

};


module.exports = s3;
module.exports.listLocalizedObjects = listLocalizedObjects;
module.exports.getPublishedEntities = getPublishedEntities;
module.exports.getPublishedFileInformation = getPublishedFileInformation;
module.exports.getPublishedImages = getPublishedImages;
module.exports.uploadFile = uploadFile;
