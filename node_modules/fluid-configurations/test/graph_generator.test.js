/*
 * Run tests with:
 *   mocha test/graph_generator.test.js --watch
 */

var
  _ = require("lodash"),
  expect = require("expect.js"),

  configureEngine = require("configuration-engine"),

  // Steps
  steps = require("../lib/graph_generator/steps.js"),

  generateGraphConfig = require("../lib/graph_generator/index.js");

/**
 * Gets all the data for a given configuration-engine collection
 * This helps us comparing results
 */
function collectionData(collection) {
  return _.map(collection, function (entry) {
    return entry.getData();
  });
}

// for step-wise testing, we want to test up to certain steps in the
// expansion sequence
function generateUpTo(stepName, config) {
  var results = { config: config },
    optimized = false;

  _.each(steps, function (step) {
    results = step.fn(results);
    if (step.name === "optimizeGraph") {
      optimized = true;
    }
    if (step.name === stepName) { // break when we reach the desired function
      return false;
    }
  });

  // The opmitize step (last one on the queue) is always required
  if (!optimized) {
    steps[steps.length - 1].fn(results);
  }

  if (results.optimizedGraph) {
    results.engine = configureEngine(_.pick(results.optimizedGraph, "vertices", "edgeGroups"));
  }

  return results;
}




describe("When generating graphs from product configuration files", function () {
  var
    customerFixtures = {
      VMM: "visual-mix-and-match.json",
      Vans: "vans.json",
      TNF: "tnf.json",
      Keen: "keen.json",
      Reebok: "reebok.json",
      Oakley: "oakley.json",
      // Matouk: "matouk.json"
    };

  _.each(customerFixtures, function (file, customer) {

    describe("for the customer " + customer, function () {

      // Expected Graph fixture
      var expectedGraph,
      // Source product configs fixtures
      config,

      // Expected results configuration engine
      expectedEngine,
      expectedProduct;

      before(function () {
        expectedGraph = require("./fixtures/graphs/" + file);
        config = require("./fixtures/products/" + file);
        expectedEngine = configureEngine(expectedGraph);
        expectedProduct = expectedEngine.product();
      });

      after(function () {
        configureEngine.flushAll();
      });




      describe("and loading utilities, it:", function () {
        var utils;

        before(function () {
          utils = generateUpTo("loadUtilities", config).utils;
        });

        it("should expose util.autocast", function () {
          expect(utils.autocast("23.00")).to.be(23);
          expect(utils.autocast("false")).to.be(false);
        });

        it("should expose util.getIdAsInt", function () {
          expect(utils.getIdAsInt("p_20637_ca_32058.p_20637_ca_32056")).to.be(32056);
          expect(utils.getIdAsInt("av123")).to.be(123);
        });

        it("should expose util.getUniqueObjectId", function () {
          expect(utils.getUniqueObjectId({foo: "bar"})).to.be("a5e744");
        });

        it("should expose util.addFutureRelationships", function () {
          expect(utils.addFutureRelationships).to.be.a(Function);
        });

        it("should expose util.getDelayedRelationships", function () {
          expect(utils.getDelayedRelationships).to.be.a(Function);
        });

      });




      describe("and initializing the graph, it:", function () {
        var graph;

        before(function () {
          graph = generateUpTo("initGraph", config).graph;
        });

        it("should include the vertices array", function () {
          expect(JSON.stringify(graph.vertices)).to.be("[]");
        });

        it("should include the edges array", function () {
          expect(JSON.stringify(graph.edges)).to.be("[]");
        });

        it("should include the relationships object", function () {
          expect(JSON.stringify(graph.relationships)).to.be("{}");
        });
      });





      describe("and including the configuration structure, it:", function () {
        var structure;

        before(function () {
          structure = generateUpTo("loadConfigurationStructure", config).structure;
        });

        it("should include structure information for different configuration entries", function () {
          expect(structure).to.have.keys([
            "subAttributes",
            "sympatheticFacets",
            "areasConfiguration",
            "dictionary",
            "localization",
            "attributes",
            "facets",
            "values",
            "views",
            "valueSets",
            "facetCategories",
            "productFacets",
            "attributeGroups"
          ]);
        });
      });



      describe("and populating the graph, it:", function () {
        var stepResult;

        // Testing for a consistent graph construction convention
        // allows us to prevent bugs where we might add the same vertex
        // multiple times. The optimize_graph step hashes vertices
        // and edges in order to remove duplicates.
        // It's simpler for us to remove duplicates after the graph is generated
        // than trying to keep track of what already exists on the graph
        // at each step. For example views can be included on multiple steps
        before(function () {
          stepResult = generateUpTo("all", config);
        });

        it("should keep vertex properties on a predictable state to allow hashing", function () {
          _.each(stepResult.graph.vertices, function (vertex) {
            expect(_.keys(vertex).slice(0, 2).join(",")).to.be("id,ns");
          });
        });

        it("should keep edge properties on a predictable state to allow hashing", function () {
          var expected = "from,to,type";
          _.each(stepResult.graph.edges, function (edge) {
            var current = _.keys(edge).slice(0, 3).join(",");
            if (current !== expected) {
              console.log(edge);
            }
            expect(current).to.be(expected);
          });
        });

      });



      describe("and loading the product vertex, it:", function () {
        var product;

        it("should add the product to the graph in a way that can be instantiated", function () {
          product = generateUpTo("addPricing", config)
            .engine
            .product();
          expect(product.id).to.be(config.id);
        });

        it("should contain the same data as the expected configuration-engine product", function () {
          expect(product.getData()).to.be.eql(expectedProduct.getData());
        });

      });



      describe("and loading configurable attribute vertices, it:", function () {
        var product, stepResult;

        it("should add the ca to the graph in a way that can be instantiated", function () {
          stepResult = generateUpTo("addConfigurableAttributes", config);
          product = stepResult
            .engine
            .product();
          expect(product.allAttributes()).to.be.an(Array);
        });

        it("should include top level cas", function () {
          var expected = expectedProduct.allAttributes(),
            cas = product.allAttributes();

          expect(cas.length).to.be(expected.length);
          expect(collectionData(cas)).to.eql(collectionData(expected));
        });

        it("should extract sub-attributes", function () {
          var expected = expectedProduct.allAttributes(),
            cas = product.allAttributes();
          expect(cas.length).to.be(expected.length);
          expect(collectionData(cas)).to.eql(collectionData(expected));
        });

        it("should include future relationships for the ca", function () {
          _.each(product.allAttributes(), function (ca) {
            var caRelationships = stepResult.graph.relationships["ca:" + ca.id];
            // Not much we can test here at this point in a generic way
            // other than the relationship is defined
            expect(caRelationships).to.be.ok();
          });
        });

      });



      describe("and linking attribute groups, it:", function () {
        var product, stepResult, hasAg, ags = [], expectedAgs;

        it("should know if the product has attributeGroups", function () {
          stepResult = generateUpTo("linkAttributeGroups", config);

          product = stepResult
            .engine
            .product();
          hasAg = product.hasAttributeGroups();
          expect(_.isBoolean(hasAg)).to.be.ok();
        });

        it("should be able to get attribute groups", function () {
          if (hasAg) {
            ags = product.attributeGroups();
            expectedAgs = expectedProduct.attributeGroups();
            expect(ags).to.eql(expectedAgs);
          }
        });

        it("should be able to get attribute group view", function () {
          _.each(ags, function (ag, key) {
            expect(ag.view()).to.eql(expectedAgs[key].view());
          });
        });


        it("should be able to get attribute group configurable attributes", function () {
          _.each(ags, function (ag, key) {
            expect(ag.attributes()).to.eql(expectedAgs[key].attributes());
          });
        });

        it("should get the attribute group where a configurable attribute is contained", function () {
          var expectedCas = expectedProduct.allAttributes(),
            cas = product.allAttributes();

          _.each(expectedCas, function (expectedCa, key) {
            expect(cas[key].attributeGroup()).to.be.eql(expectedCa.attributeGroup());
          });
        });

      });





      describe("and loading attribute value vertices, it:", function () {
        var product, stepResult, avs;

        it("should add the av to the graph in a way that can be instantiated", function () {

          stepResult = generateUpTo("addAttributeValues", config);
          product = stepResult
            .engine
            .product();

          _.each(product.allAttributes(), function (ca) {
            avs = ca.selectableValues();
            if (avs.length > 0) {
              return false;
            }
          });
          expect(avs).to.be.an(Array);
        });



        it("should include know if cas are sympathetic filter slaves, it:", function () {
          var expectedCas = expectedProduct.allAttributes(),
            cas = product.allAttributes();

          _.each(expectedCas, function (expectedCa, key) {
            expect(cas[key].isSympatheticFilterSlave()).to.be(expectedCa.isSympatheticFilterSlave());
          });
        });


        it.skip("should include the same avs, it:", function () {
          var expectedCas = expectedProduct.allAttributes(),
            cas = product.allAttributes();

          _.each(expectedCas, function (expectedCa, key) {
            var expectedAvs = expectedCa.selectableValues(),
              currentAvs = cas[key].selectableValues();

            expect(cas[key].explain()).to.eql(expectedCa.explain());
            expect(currentAvs).to.eql(expectedAvs);
          });
        });

      });





      describe("and loading value usage vertices, it:", function () {
        var product, stepResult, expectedCas, cas;

        before(function () {
          stepResult = generateUpTo("linkValueUsages", config);
          product = stepResult
            .engine
            .product();

          expectedCas = expectedProduct.allAttributes();
          cas = product.allAttributes();
        });


        it("should get value usages", function () {
          _.each(expectedCas, function (expectedCa, key) {
            expect(cas[key].valueUsages()).to.eql(expectedCa.valueUsages());
          });
        });

        it("should select the right view to display when a associatedView is defined", function () {
          _.each(expectedCas, function (expectedCa, key) {
            var expectedVus = expectedCa.valueUsages();
            _.each(cas[key].valueUsages(), function (vu, idx) {
              expect(vu.viewName()).to.be(expectedVus[idx].viewName());
            });
          });
        });


      });




      // The product should know what currencies are defined
      // this is not available on the old graph generator so we
      // just assert that we have some currencies defined.
      describe("and adding pricing information, it:", function () {
        var product, stepResult, availableCurrencies, expectedCas, cas;

        before(function () {
          stepResult = generateUpTo("addPricing", config);
          product = stepResult
            .engine
            .product();

          expectedCas = expectedProduct.allAttributes();
          cas = product.allAttributes();
        });

        it("should include available currencies for a product", function () {
          availableCurrencies = product.availableCurrencies();
          expect(availableCurrencies.length).to.be.above(0);
        });

        it("should calculate product price properly", function () {
          _.each(availableCurrencies, function (currency) {
            expect(product.price(currency)).to.be(expectedProduct.price(currency));
          });
        });

        it("should calculate value usage upcharges properly", function () {
          // get ca's attributeValues
          _.each(cas, function (ca, key) {
            var expectedCa = expectedCas[key],
              expectedValues = expectedCa.selectableValues();

            expect(ca).to.eql(expectedCa);

            _.each(ca.selectableValues(), function (av, key) {
              var expectedAv = expectedValues[key],
                vu, expectedVu;
              expect(av).to.eql(expectedAv);

              vu = ca.getValueUsageForValue(av);
              expectedVu = expectedCa.getValueUsageForValue(expectedAv);

              if (vu) {
                _.each(availableCurrencies, function (currency) {
                  var calculated = vu.getUpchargeFor(av, currency),
                    expected = expectedVu.getUpchargeFor(expectedAv, currency);
                  if (calculated !== expected) {
                    console.log(stepResult.graph.issues);
                  }
                  expect(calculated).to.be(expected);
                });
              }
            });
          });
        });
      });






      describe("and loading view vertices, it:", function () {
        var product, stepResult;

        before(function () {
          stepResult = generateUpTo("linkViews", config);
          product = stepResult
            .engine
            .product();
        });


        it("should get the default view for the product", function () {
          expect(product.defaultViewName()).not.to.be(null);
          expect(product.defaultViewName()).to.be(expectedProduct.defaultViewName());
        });

        // it should know what views are selected for a given value usage
        // valueUsages

        it("should get the view names for cas", function () {
          // Used by TNF and Reebok
          var expectedCas = expectedProduct.allAttributes(),
            cas = product.allAttributes();
          _.each(expectedCas, function (expectedCa, key) {
            expect(cas[key].viewName()).to.be(expectedCa.viewName());
          });
        });
      });




      describe("and using product facets, it:", function () {
        var product, stepResult;

        before(function () {
          stepResult = generateUpTo("addFacets", config);
          product = stepResult
            .engine
            .product();
        });

        // Custom facets where not included on the initial graph prototype so
        // we don't have an expectedProduct to test against this time
        it("should link custom facets to the product", function () {
          _.each(product.facets(), function (pf) {
            expect(pf.getData().name).to.be.ok();
            expect(pf.getData().values).to.be.an(Array);
          });
        });

      });





      describe("and loading view rotation sequences, it:", function () {});




      describe("and loading visibility rule vertices, it:", function () {
        var product, stepResult;

        before(function () {
          stepResult = generateUpTo("linkCaVisibilityRules", config);
          product = stepResult
            .engine
            .product();
        });


        it("should get the visiblity rules for cas", function () {
          var expectedCas = expectedProduct.allAttributes(),
            cas = product.allAttributes();
          _.each(expectedCas, function (expectedCa, key) {
            // Omitting id since we moved from same as ca:id to a consistent
            // hash
            var generated, expected,
              vr = cas[key].visiblityRule(),
              expectedVr = expectedCa.visiblityRule();

            if (!expectedVr && !vr) {
              // no VR defined
              return;
            }
            generated = _.omit(vr.getData(), "id", "vertexKey");
            expected = _.omit(expectedVr.getData(), "id", "vertexKey");
            expect(generated).to.eql(expected);
          });
        });
      });





      describe("and generating edgeGroups, it:", function () {
        it("should include all edge groups", function () {
          var current = _.keys(generateGraphConfig(config).graph.edgeGroups),
            expected = _.keys(expectedGraph.edgeGroups);
          expect(current).to.be.eql(expected);
        });
      });

    });
  });
});
