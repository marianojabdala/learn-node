var expect = require("expect.js"),
  _ = require("lodash"),
  path = require("path"),
  async = require("async"),
  fs = require("fs"),
  exec = require("child_process").exec,
  local_dir = path.resolve(__dirname + "/../tmp/test-data"),
  fluidConfigurations = require("../"),

  s3Settings = {
    bucket: "fluid-test-resources",
    prefix: "modules/fluid-configurations/test-data/" +
      (process.env.USER || "anonymous") + "/"
  },

  validateLocalFilesAgainstIndex,
  validateJsonFiles;

if (!process.env.DEV_MODE) {
  s3Settings.prefix += (new Date()).getTime() + "/";
}


describe("Fluid Configurations Public API", function () {
  var testResults = {},
    paramsTnf = {
      customer: 1443,
      workflow: "prod",
      environment: "prod"
    },
    paramsUgg = {
      customer: 1496,
      workflow: "prod",
      environment: "prod"
    };


  describe("When using the getPublishedIndexes method, it:", function () {

    it("should allow us to get published indexes", function (done) {
      this.timeout(1000 * 60);
      fluidConfigurations.getPublishedIndexes(paramsTnf, function (err, indexes) {
        if (err) { throw err; }
        expect(indexes.length).to.be.above(5);
        testResults.tnfIndexes = indexes;
        done();
      });
    });


    it("should include workflow customerId and environment on all index entries", function () {

      expect(_.uniq(_.pluck(testResults.tnfIndexes, "customerId")))
        .to.eql([1443]);

      expect(_.uniq(_.pluck(testResults.tnfIndexes, "workflow")))
        .to.eql(["prod"]);

      expect(_.uniq(_.pluck(testResults.tnfIndexes, "environment")))
        .to.eql(["prod"]);

    });



    it("should include catalogId, productId or customerId", function () {
      expect(_.compact(_.uniq(_.pluck(testResults.tnfIndexes, "productId"))))
        .to.eql([20104, 20105, 20526, 20527]);

      expect(_.compact(_.uniq(_.pluck(testResults.tnfIndexes, "catalogId"))))
        .to.eql([1, 2, 3, 14]);

      expect(_.compact(_.uniq(_.pluck(testResults.tnfIndexes, "locale"))))
        .to.eql(["EN", "en_us", "fr_ca"]);
    });



    it("should include index entry type", function () {
      expect(_.uniq(_.pluck(testResults.tnfIndexes, "type")))
        .to.eql([
          "customerConfig",
          "customerLocalization",
          "productConfig",
          "catalogConfig",
          "catalogTemplate",
          "productLocalization"
        ]);
    });

    it("should memoize published indexes", function (done) {
      this.timeout(500);
      fluidConfigurations.getPublishedIndexes(paramsTnf, function (err, indexes) {
        if (err) { throw err; }
        expect(indexes).to.eql(testResults.tnfIndexes);
        done();
      });
    });

  });



  describe("When using the downloadConfigurations method, it:", function () {

    after(function (done) {
      exec("rm -rf " + local_dir, done);
    });

    it("should download an explicit index", function (done) {
      this.timeout(1000 * 60 * 5);

      fluidConfigurations.downloadConfigurations({
        indexes: testResults.tnfIndexes,
        local_dir: local_dir
      }, function (err, files) {
        if (err) { throw err; }
        validateLocalFilesAgainstIndex(files, testResults.tnfIndexes, done);
      });

    });

    it("should not download new files if the index is up to date", function (done) {
      this.timeout(1000 * 60 * 5);
      fluidConfigurations.downloadConfigurations({
        indexes: testResults.tnfIndexes,
        local_dir: local_dir
      }, function (err, files) {
        if (err) { throw err; }
        expect(files.length).to.be(0);
        done();
      });

    });

    it("should generate the index if not present", function (done) {
      this.timeout(1000 * 60 * 5);
      var options = _.defaults({}, paramsUgg, {
        local_dir: local_dir
      });

      fluidConfigurations.downloadConfigurations(options, function (err, files, indexes) {
        if (err) { throw err; }
        expect(files.length).to.be.above(0);
        testResults.uggIndexes = indexes;
        validateLocalFilesAgainstIndex(files, indexes, done);
      });
    });

    it("should allow forcing re-downloading files via options.reDownload = true", function (done) {
      this.timeout(1000 * 60 * 5);
      var options = _.defaults({}, paramsUgg, {
        local_dir: local_dir,
        reDownload: true
      });

      fluidConfigurations.downloadConfigurations(options, function (err, files) {
        if (err) { throw err; }
        expect(files.length).to.be.above(0);
        validateLocalFilesAgainstIndex(files, options.indexes, done);
      });
    });

  });


  describe("When processing downloaded configurations", function () {

    after(function (done) {
      exec("rm -rf " + local_dir, done);
    });

    it("should always process files as JSON", function (done) {
      this.timeout(1000 * 60 * 5);

      var options = _.defaults({}, paramsUgg, {
        local_dir: local_dir
      });

      fluidConfigurations.processConfigurations(options, function (err, results) {
        if (err) { throw err; }
        expect(results.json.files.length).to.be.above(0);
        validateJsonFiles(results.json.files, done);
      });
    });

    it("should allow using the catalog processor", function (done) {
      this.timeout(1000 * 30);

      var options = _.defaults({}, paramsUgg, {
        local_dir: local_dir,
        processors: ["catalog"]
      });

      fluidConfigurations.processConfigurations(options, function (err, results) {
        if (err) { throw err; }
        expect(results.catalog.files.length).to.be.above(0);
        validateJsonFiles(results.catalog.files, done);
      });
    });


    it("should allow using multiple processors", function (done) {
      this.timeout(1000 * 30);

      var options = _.defaults({}, paramsUgg, {
        local_dir: local_dir,
        processors: ["product", "catalog", "relationships"]
      });

      fluidConfigurations.processConfigurations(options, function (err, results) {
        if (err) { throw err; }
        var product_catalogs,
          preferences;

        expect(results.product.files.length).to.be.above(0);
        expect(results.catalog.files.length).to.be.above(0);
        expect(results.relationships.files.length).to.be.above(0);
        expect(results.preferences.files.length).to.be.above(0);
        expect(results.customer.files.length).to.be.above(0);

        product_catalogs = require(results.relationships.files[0]);
        expect(product_catalogs["20391"]).to.contain(12);

        preferences = require(results.preferences.files[0]);
        expect(preferences.version).to.be.above((new Date()).getTime() - 10000);
        expect(preferences.locales.default).to.be("en_us");

        async.each([
            results.product.files,
            results.catalog.files,
            results.relationships.files,
            results.customer.files,
            results.preferences.files
          ],
          validateJsonFiles,
          done);
      });
    });


  });


  describe("When uploading configurations to S3", function () {

    var options = _.defaults({}, paramsUgg, {
      local_dir: local_dir,
      s3: s3Settings
    }),
    uploadedJsonCount;

    after(function (done) {
      exec("rm -rf " + local_dir, done);
    });

    it("should upload json configurations", function (done) {

      this.timeout(1000 * 60 * 5);

      // Uploads processed files to S3
      fluidConfigurations.uploadToS3(_.defaults({
        processors: "json"
      }, options), function (err, uploadedFiles, upToDateObjects) {
        if (err) { throw err; }
        uploadedJsonCount = uploadedFiles.length;
        expect(uploadedFiles.length).to.be.above(0);
        expect(upToDateObjects.length).to.be(0);
        done();
      });
    });

    it("should skip uploading up to date json configurations", function (done) {
      this.timeout(1000 * 60 * 5);

      // Uploads processed files to S3
      fluidConfigurations.uploadToS3(_.defaults({
        processors: "json"
      }, options), function (err, uploadedFiles, upToDateObjects) {
        if (err) { throw err; }
        // the preferences.json is added when uploading processed configurations
        expect(upToDateObjects.length).to.be(uploadedJsonCount);
        expect(uploadedFiles.length).to.be(0);
        done();
      });
    });

    it("should upload processed configurations", function (done) {
      this.timeout(1000 * 60 * 5);
      // Uploads processed files to S3
      fluidConfigurations.uploadToS3(options,
        function (err, uploadedFiles) {
          if (err) { throw err; }
          var uploaded = JSON.stringify(uploadedFiles, null, 2);

          expect(uploadedFiles.length).to.be.above(0);

          expect(uploaded).to.contain("catalog/12/settings-en_us.json");
          expect(uploaded).to.contain("catalog/12/settings.json");
          expect(uploaded).to.contain("product/20391/settings-en_us.json");
          expect(uploaded).to.contain("product/20409/settings.json");
          expect(uploaded).to.contain("prod/prod/1496/settings-en_us.json");
          expect(uploaded).to.contain("prod/prod/1496/preferences.json");
          expect(uploaded).to.contain("1496/relations/product_catalogs.json");
          expect(uploaded).to.contain("catalog/12/report.json");
          expect(uploaded).to.contain("product/20391/report.json");
          expect(uploaded).to.contain("prod/prod/1496/preferences.json");
          expect(uploaded).to.contain("prod/prod/1496/settings.json");

          done();
        });
    });
  });


});


validateJsonFiles = function (files, callback) {
  async.map(files, function (file, callback) {
    fs.readFile(file, function (err, buffer) {
      if (err) { return callback(err); }
      try {
        JSON.parse(buffer.toString());
      } catch (e) {
        return callback(e);
      }
      callback();
    });
  }, callback);
};

validateLocalFilesAgainstIndex = function (files, indexes, callback) {
  async.each(_.pluck(indexes, "Key"), function (path, callback) {
    path = local_dir + "/admin-published/" + path;

    if (files.indexOf(path) === -1) {
      return callback(new Error("The file " + path + " is not included on the list of downloaded files"));
    }
    fs.exists(path, function (exists) {
      callback(exists ? null : new Error("File " + path + " not found"));
    });
  }, function (err) {
    callback(err);
  });
};
